<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"richard-zheng.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="人生天地间，忽如远行客。">
<meta property="og:type" content="website">
<meta property="og:title" content="湖面">
<meta property="og:url" content="https://richard-zheng.github.io/index.html">
<meta property="og:site_name" content="湖面">
<meta property="og:description" content="人生天地间，忽如远行客。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Richard Zheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://richard-zheng.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>湖面</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">湖面</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Richard Zheng</p>
  <div class="site-description" itemprop="description">人生天地间，忽如远行客。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/12/15/front-end-article-recommendation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/15/front-end-article-recommendation/" class="post-title-link" itemprop="url">前端入门好文推荐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-15 23:43:00" itemprop="dateCreated datePublished" datetime="2021-12-15T23:43:00+08:00">2021-12-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近一周简单学了下 React 和 JavaScript，把遇到的各种难点整理一下，附上我能找到的好文：</p>
<h2 id="javascript">JavaScript</h2>
<p>通用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/">现代 JavaScript 教程</a>（The Modern JavaScript Tutorial）</li>
</ul>
<p>理解 this 和函数调用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and "this"</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904113352736776">this绑定的四种方式：new，显式，隐式，默认</a></li>
</ul>
<p>理解箭头函数</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数 - MDN</a></li>
</ul>
<p>面向对象</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022776150">JS中的构造函数、原型、原型链</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链 - MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/">Understanding "Prototypes" in JavaScript</a></li>
</ul>
<p>模块</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/javascript-modules-a-beginner-s-guide-783f7d7a5fcc/#.jw1txw6uh">JavaScript Modules: A Beginner’s Guide</a></li>
</ul>
<p>函数式编程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide">Mostly adequate guide to functional programming (in javascript)</a>（<a target="_blank" rel="noopener" href="https://github.com/llh911001/mostly-adequate-guide-chinese">中文译版</a>）</li>
</ul>
<h2 id="css">CSS</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040718161">10个好用的的css框架</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/taniarascia/primitive">Primitive UI</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/material-design-lite">Material Design Lite</a></li>
</ul>
<h2 id="react">React</h2>
<p>官方文档作为入门资料已经很好了。下面是进阶补充，主要是思想介绍：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2020/09/react-hooks-useeffect-tutorial.html">轻松学会 React 钩子：以 useEffect() 为例</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/react-guide/react-basic">React 设计思想</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/424391079">奇葩说框架之React编译原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/react-art-of-simplity/">深入浅出 React</a> （<a target="_blank" rel="noopener" href="https://www.kancloud.cn/kancloud/react-in-depth/47779">看云文档</a>）</li>
<li><a target="_blank" rel="noopener" href="https://reactpatterns.com/">React Patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040272535">React 并发功能体验-前端的并发模式已经到来。</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/12/04/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/04/dynamic-programming/" class="post-title-link" itemprop="url">简析动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 15:37:00" itemprop="dateCreated datePublished" datetime="2021-12-04T15:37:00+08:00">2021-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
</blockquote>
<p>动态规划是一种在 OI 中非常常见的算法。如上所述，动态规划的精髓在于<strong>子问题</strong>，然而并不是所有和子问题相关的算法都是动态规划。要搞清楚动态规划<strong>是什么、为什么、怎么用</strong>，我们可以从两种方向来认识。</p>
<h2 id="重叠子问题">重叠子问题</h2>
<p><em>例题1：</em></p>
<p>蒜头君很喜欢爬楼梯，这一次，他获得了一个特异功能，每次可以跳跃任意奇数的阶梯。比如他初始在楼底，跨越一个阶梯到达 11 号阶梯，或者跨越 3 个楼梯到达 3 号阶梯。如下图</p>
<figure>
<img src="https://res.jisuanke.com/img/upload/20180403/3110ec4f381651d86db508f2d5968c721a65e126.png" alt="蒜头君爬楼梯" /><figcaption aria-hidden="true">蒜头君爬楼梯</figcaption>
</figure>
<p>为了选出一种最轻松的爬楼梯的方式，蒜头君想把所有不同的到达楼顶的方式都尝试一遍。对于一共有 <span class="math inline">\(n\)</span> 个阶梯的楼梯，蒜头君一共有多少种方法从楼底到达楼顶？</p>
<p>最暴力的做法就是递归搜一遍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">path</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; n - i &gt;= <span class="number">0</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">path</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 <span class="math inline">\(O(n!)\)</span>，但其实这离答案就差一点。</p>
<p><strong>Tips:</strong> 你要知道第 <span class="math inline">\(n\)</span> 个阶梯的方案数，你只需要知道到第 <span class="math inline">\(n-1\)</span>, <span class="math inline">\(n-3\)</span>, <span class="math inline">\(n-5\)</span>…… 个阶梯的方案数。</p>
<p>我怎么知道？存下来就行了呗：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll memory[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">path</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memory[n]) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; n - i &gt;= <span class="number">0</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">path</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        memory[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来，时间复杂度就变成 <span class="math inline">\(O(n)\)</span> 了。</p>
<p>思路：因为 <span class="math display">\[
path_{n} =path_{n-1} +path_{n-3}+...+path_{n-(2k-1)}
\]</span> 所以用数组记录每个子问题的解以避免重复计算。</p>
<p>这就是<strong>重叠子问题</strong>，通过对重叠子问题的记忆，可以极大地优化很暴力的算法。</p>
<p>重叠子问题，在编程层面上常常表现为<strong>纯函数</strong>。如果你曾经接触过函数式编程（比如使用 React 之类的库或者 Haskell 语言），你可能听说过这个概念。纯函数是一个满足以下条件的函数：</p>
<ul>
<li>输入参数相同时，输出值相同。</li>
<li>不能有语义上可观察的副作用，比如更改输出值以外变量的内容等。</li>
</ul>
<p>上文所述 <code>path</code> 函数正好满足这些要求。因此，我们可以放心地根据参数缓存它的返回值。</p>
<h2 id="最优子结构">最优子结构</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">Leetcode 最小路径和</a></p>
<p>给定一个包含非负整数的 <span class="math inline">\(m\times n\)</span> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>同样先用递归写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_path</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_path</span>(x, y - <span class="number">1</span>) + grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_path</span>(x - <span class="number">1</span>, y) + grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min_path</span>(x - <span class="number">1</span>, y), <span class="built_in">min_path</span>(x, y - <span class="number">1</span>)) + grid[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在肯定在想：记忆化！开个数组 <code>min_path[x][y]</code> 把遍历到的结果全存下来，如果已经算过直接返回不就行了！</p>
<p>先等一下，我们先想想，这个 <code>min_path</code> 函数在语义上是什么用途呢？是从 <span class="math inline">\((1,1)\)</span> 前往 <span class="math inline">\((x,y)\)</span> 的最小距离。那你怎么就肯定 <span class="math inline">\((x,y)\)</span> 变了以后，你存下来的还是对应的最短距离呢？</p>
<p>换句话说，记忆化的前提是：无论终点是哪一个，到达终点的路径上的点之间走的<strong>全部都是最短距离</strong>，不存在有需要绕路的情况。</p>
<p>这就是<strong>最优子结构</strong>。一个解是最优的，那么它在子问题中也必定是最优的。</p>
<p>再看一道题：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a></p>
<p>简单写个<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/64333237">暴力递归</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">351</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">121</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> b[MAXM];</span><br><span class="line"><span class="keyword">bool</span> used[MAXM];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_scores</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[x];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max_scores</span>(x - b[i]) + a[x]);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max_scores</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，还能记忆化吗？</p>
<p>不行了。因为函数返回的值不但跟终点位置 <code>x</code> 有关，还跟使用爬行卡片情况的数组 <code>used</code> 有关。显然，这个函数不满足上面所说纯函数的两个要求。如果你把 <code>used</code> 也当成参数加进来，那么每次 <code>used</code> 的值都会不同，记忆化没有意义。</p>
<p>这是为什么呢？原因就是现在我们的函数 <code>max_scores(int x)</code> 不具有最优子结构了。当前贪心地把前 <code>x</code> 个格子的分数拿到最大用掉了爬行卡片，后面就会受影响得不到最优的结果。正是因为有了最优子结构，子问题才会重叠。<strong>最优子结构是因，重叠子问题是果。</strong></p>
<p>那，这题就不能用动态规划做了？</p>
<p>仔细观察题目：</p>
<blockquote>
<p>分成4种不同的类型（<span class="math inline">\(M\)</span> 张卡片中不一定包含所有 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1, 2, 3, 4 四个数字之一。</p>
</blockquote>
<p>总共只有四种类型的卡片，而相同数字的卡片没有任何区别。重叠子问题！写一下试试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">351</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">121</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXB = <span class="number">41</span>;</span><br><span class="line"><span class="keyword">int</span> score[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> memory[MAXB][MAXB][MAXB][MAXB];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_scores</span><span class="params">(<span class="keyword">int</span>* use)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">3</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> score[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;  <span class="comment">// start from 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            x += use[i] * (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (use[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                use[i]--;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max_scores</span>(use) + score[x]);</span><br><span class="line">                use[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; score[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        cnt[--b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max_scores</span>(cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/64361130">顺利 AC</a>. 我们可以发现，选取递归函数的参数和语义是解决此问题的关键。</p>
<p>虽然这个函数在形式上仍然不满足纯函数的要求，但是这仅仅是为了方便。你完全可以用更加啰嗦的形式，将参数由一个数组指针改成四个整型，把这个函数改造成一个纯函数。</p>
<h2 id="形式不重要">形式不重要</h2>
<p>动态规划在狭义上一般都是从最小的子问题开始，一步一步求解更大规模的问题，所以它的实现都是循环，而不是递归。然而，上面讲的全部都是递归，这种方法会被单独称作<strong>记忆化搜索</strong>。但是我这么做的原因正是想说明一点：形式不重要，重要的是子问题的解之间的依赖关系。</p>
<p>这里引用<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290/answer/96997659">知乎上的一篇回答</a>：</p>
<blockquote>
<p>动态规划的初衷是，</p>
<p>通过找到合适的角度，将所求解的目标值在某（几）个维度上展开，使得最终的目标能变成一个函数在某组自变量下的值：比如在经典题目数字三角形中，将“和”在“横纵坐标”上展开，那么最终的目标就是 <span class="math inline">\(max\{f(n - 1, i)\}\)</span>，<span class="math inline">\(i\)</span> 从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n-1\)</span>.</p>
<p>这种展开需要满足的性质是：首先，展开后，函数值是可以由自变量唯一确定的；其次，函数有一种递推表达式；最后，可以通过某种求值顺序（待求的所有函数值的依赖关系形成一个有向无环图），从显然的初值开始依次求，直到目标值。</p>
<p>至于是用循环解，还是记忆化搜索解，还是用 BFS 或者 DFS 解，都不本质。这个依赖于上文所说的有向无环图的结构。</p>
</blockquote>
<p>而求解这个问题，正是遍历这张有向无环图上和答案点直接或间接相连的所有点。</p>
<p>我们可以用最暴力的方法去递归，这就对应着在那个有向无环图中从我们要求解的那个点开始，完全按照有向边走。可以想见，这么走必定会大量重复经过点，这就是它低效的原因。</p>
<p>那我们可以怎么优化呢？记忆化搜索给出的答案是把走过的点的结果存起来，下一次就不往下走了，这样就避免了绝大部分重复经过的情况。</p>
<p>而使用循环的动态规划则是从最底部已知的边界点开始，倒着往上遍历。它并不依赖图之间的有向边遍历，而是按照预设好的路线遍历。这就需要保证遍历到的每个点的依赖都已被遍历。</p>
<p>所以说，能用动态规划求解的问题一定能用记忆化搜索求解。</p>
<p>计算机只会穷举。所有算法都是在<strong>充分利用给定的条件</strong>，让计算机<strong>更优雅地</strong>穷举。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/12/02/flarum-setup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/02/flarum-setup/" class="post-title-link" itemprop="url">安装和配置 Flarum</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-02 11:45:00" itemprop="dateCreated datePublished" datetime="2021-12-02T11:45:00+08:00">2021-12-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文采用 Ubuntu 20.04 LTS.</p>
<h2 id="安装-mariadbphp-和-composer">安装 MariaDB、PHP 和 Composer</h2>
<p>更新源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>首先安装 php（Apache 2 的 php 模块）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 mariadb-server php7.4 libapache2-mod-php7.4 php7.4-common php7.4-mbstring php7.4-xmlrpc php7.4-soap php7.4-mysql php7.4-gd php7.4-xml php7.4-curl php7.4-cli php7.4-zip php7.4-tokenizer wget unzip curl git -y</span><br></pre></td></tr></table></figure>
<p>然后全局安装 Composer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">sudo mv composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br></pre></td></tr></table></figure>
<h2 id="配置数据库">配置数据库</h2>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<ul>
<li>Enter current password for root (enter for none): Just press the Enter</li>
<li>Set root password? [Y/n]: Y</li>
<li>New password: Enter password</li>
<li>Re-enter new password: Repeat password</li>
<li>Remove anonymous users? [Y/n]: Y</li>
<li>Disallow root login remotely? [Y/n]: Y</li>
<li>Remove test database and access to it? [Y/n]: Y</li>
<li>Reload privilege tables now? [Y/n]: Y</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br><span class="line">create database flarum character set utf8mb4 collate utf8mb4_unicode_ci;</span><br><span class="line">CREATE USER &#x27;flarumuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password_here&#x27;;</span><br><span class="line">GRANT ALL ON flarum.* TO &#x27;flarumuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;user_password_here&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure>
<h2 id="安装-flarum-并配置-apache">安装 Flarum 并配置 Apache</h2>
<p>创建目录并使当前用户成为所有者。这是为了避免以 root 运行 Composer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/flarum</span><br><span class="line">sudo chown -R $USER:$USER /var/www/flarum</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/flarum</span><br><span class="line">composer create-project flarum/flarum .</span><br></pre></td></tr></table></figure>
<p>然后，使 Apache 成为该目录的所有者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R www-data:www-data /var/www/flarum</span><br></pre></td></tr></table></figure>
<p>添加 Apache 的 VirtualHost</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/flarum.conf</span><br></pre></td></tr></table></figure>
<p>写入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin admin@your_domain.com</span><br><span class="line">    DocumentRoot /var/www/flarum/public</span><br><span class="line">    ServerName your-server</span><br><span class="line">    &lt;Directory /var/www/flarum/public&gt;</span><br><span class="line">        Options FollowSymlinks</span><br><span class="line">        AllowOverride All</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    ErrorLog $&#123;APACHE_LOG_DIR&#125;/your-domain.com_error.log</span><br><span class="line">    CustomLog $&#123;APACHE_LOG_DIR&#125;/your-domain.com_access.log combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>启用新的 VirtualHost 和 URL 重写模块，并通过重启服务来应用更改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite flarum</span><br><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo a2dissite 000-default.conf</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>
<p>检查是否已打开防火墙。</p>
<h2 id="配置-https">配置 HTTPS</h2>
<p>安装 certbot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install certbot python3-certbot-apache</span><br></pre></td></tr></table></figure>
<p>确保 <code>flarum.conf</code> 中填入了正确的域名。</p>
<p>允许 SSL 通过防火墙</p>
<ul>
<li>检查云服务提供商的防火墙已打开 443 端口</li>
<li>检查 <code>ufw</code> 设置 <code>sudo ufw status</code></li>
</ul>
<p>申请 SSL 证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --apache</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/12/01/common-wa-reasons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/01/common-wa-reasons/" class="post-title-link" itemprop="url">常见 Wrong Answer 原因集锦</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 01:11:00" itemprop="dateCreated datePublished" datetime="2021-12-01T01:11:00+08:00">2021-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="变量运算过程中溢出">变量运算过程中溢出</h2>
<blockquote>
<p>Codeforces <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1609/submission/137522685">#137522685</a></p>
<p>Diagnostics detected issues [cpp.clang++-diagnose]: p71.cpp:66:40: runtime error: signed integer overflow: 99999 * 100000 cannot be represented in type 'int'</p>
</blockquote>
<p>尽管指定运算结果会被赋值/加到一个较大的数据类型（比如 long long），运算过程中仍然会有精度问题。</p>
<p>解决方案：保证所有运算中变量数据类型一致。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/11/29/self-built-free-blog-the-easy-way/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/self-built-free-blog-the-easy-way/" class="post-title-link" itemprop="url">零编程基础自建免费博客指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-29 04:12:00" itemprop="dateCreated datePublished" datetime="2021-11-29T04:12:00+08:00">2021-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文的标题中强调了“零基础”，但是你仍然需要用到一些常见的开发工具。但请放心，上手使用这些工具并不难！这只需要你有足够的耐心，和一定的信息搜索能力。另外，如果能稍微了解一下原理而不是不求甚解拿来就用，那么维护博客对你来说就更不是件难事。</p>
<h2 id="从这里开始">从这里开始</h2>
<p>Hexo 使用 Markdown 作为文章的格式，所以你需要了解 <a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 标记语言</a> 并选择一个趁手的 Markdown 编辑器。这方面的选择很多，我个人以前一直在用 Typora，但是最近它开始收费了。所以我推荐你用开源的在线 Markdown 编辑器 <a target="_blank" rel="noopener" href="https://markdown.lovejade.cn/?utm_source=markdown.lovejade.cn&amp;pid=about-arya">Arya</a>. 即时预览的界面用起来几乎把学习成本降到了最低。</p>
<h3 id="原理">原理</h3>
<p>为什么 Hexo 的运作不需要服务器呢？其实 Hexo 只干了一件事：把编辑器输出的 Markdown 文档（Microsoft Word 虽然也是这一类文件，但是不被 Hexo 支持）转换成 HTML 5 网页（包括 HTML、CSS、JavaScript）。而这些网页从此就算「独立」了：不需要与生成它的那台机器相连接，它自己就能在任何能打开它的浏览器上工作，也不需要在任何服务器上运行代码。所以，我们只需要给这些网页找一个「网盘」（前提是得支持 HTTP 连接），就能通过访问这个网盘打开网页了。</p>
<p>而是谁运行 Hexo，编译输出网页呢？我们这里用的是 Cloudflare 免费提供的自动构建服务器。你也可以在你自己的计算机上做这个事情，具体操作请看 Hexo 官方文档。</p>
<h2 id="注册">注册</h2>
<p>你需要在两个地方注册账号：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/join">GitHub</a>：与 Git 深度集成，用于存放博客源代码库。</li>
<li><a target="_blank" rel="noopener" href="https://dash.cloudflare.com/sign-up">Cloudflare</a>：用于托管编译出的博客。</li>
</ul>
<p>这两者都只需要邮箱注册。另外尽管这次使用 Cloudflare 提供的托管服务，GitHub 同样也有类似的 GitHub Pages，而它提供的域名其中一部分将是你的用户名。加上用户名注册后不可更改，建议你选一个你喜欢的、好记且好输入的用户名。</p>
<h2 id="配置">配置</h2>
<p>注册完成之后请打开我预先准备好的 <a target="_blank" rel="noopener" href="https://github.com/Richard-Zheng/hexo-next-starter">模板</a>。然后点击 Use this template，填入你的存储库名称（如 <code>blog-source</code>）然后直接点击 Create repository from template.</p>
<p>登入 Cloudflare 控制台，点击右边栏的 Pages，然后点击 Create a project. 再下一个页面中点击 Connect GitHub，授权访问你刚刚创建的存储库（或者所有存储库）。再次回到创建 project 的页面，选中你的存储库并下一步。</p>
<ul>
<li>在 Project name 中填入你博客的名字（将成为你博客域名中的一部分，所以建议你选一个你喜欢的、好记且好输入的名字）</li>
<li>在 Build command 中填入 <code>npm run build</code></li>
<li>在 Build output directory 中填入 <code>public</code></li>
</ul>
<p>其他都保持默认，点击 Save and deploy.</p>
<p>等2到3分钟后，访问 <code>[名字].pages.dev</code>，看看博客是不是已经出现了？</p>
<h2 id="自定义">自定义</h2>
<p>Hexo 的配置是用 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 格式</a> 写的。所以简单了解一下它的格式会极大地帮助你修改配置以及减少出错概率。但是目前来说，你只需要记住以下几点：</p>
<ul>
<li>数据之间的层级关系是通过缩进来体现的，所以你必须严格遵守缩进，且只能使用空格。</li>
<li>单个配置值使用冒号结构表示 <code>key: value</code>，注意冒号后有一个空格。</li>
<li><code>#</code> 开头的为注释</li>
</ul>
<p>准备好后打开你刚刚在 GitHub 上创建的博客存储库，点开主目录下的 <code>_config.yml</code> 文件，然后在文件内容上方的右侧找到修改按钮（图标为一支笔）点开。</p>
<p>这时你就在修改你的 Hexo 配置文件了，这个配置文件的详细说明文档在 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration.html">此处</a>。但如果你没有额外要求，只用改以下几个部分：</p>
<ul>
<li><code>title</code> 网站标题</li>
<li><code>subtitle</code> 网站副标题（可选）</li>
<li><code>author</code> 你的名字</li>
<li><code>url</code> 填入<code>[名字].pages.dev</code></li>
</ul>
<p>填好以后直接点击 Commit changes 提交更改。</p>
<p>可选：然后重复相同的步骤，修改 <code>_config.next.yml</code> 文件，这是主题的配置文件。详细文档在 <a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/getting-started/configuration">此处</a>。你可以参考 <a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/#Choosing-Scheme">文档</a> 挑选一个你喜欢的主题。在大多数情况下，你不需要修改其它的配置。</p>
<p>修改完以后过2到3分钟再次访问你的博客，看看有什么变化？</p>
<h2 id="写作">写作</h2>
<p>你的文章存放在 <code>source/_posts</code> 目录中，修改文章的方式和修改配置基本相同，但是有一点需要注意：每个文章开头都会有这一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2021-01-01 00:00:00 +08:00</span><br><span class="line">tags: [标签1,标签2,标签3]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这个叫做 YAML front matter，其实就是在 Markdown 文件头部加了一段 YAML 格式的配置/说明。你需要注意的是如果文章中有数学公式需要加上一行 <code>mathjax: true</code>。</p>
<p>小技巧：Hexo 会使用每篇文章的文件名作为它的 URL，但是中文出现在 URL 中很不美观，你可以把文章英文名作为 Markdown 文件的名字（全部小写，空格换成短横线，如 <code>hello-world</code>），然后在 <code>title: 你好世界</code> 这里写这篇文章的中文名。实际页面中文章的名字全部取决于这个 <code>title</code> 的值。</p>
<p>如果要新建一篇文章，你可以导航到 <code>source/_posts</code> 目录，然后点击 Add file，选择创建新文件（直接在网页编辑）或是从本地上传 Markdown 文件。</p>
<p>每次博客存储库有更改，在2到3分钟后网站即会更新。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/11/26/template-for-programming-contest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/26/template-for-programming-contest/" class="post-title-link" itemprop="url">算法竞赛常用模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-26 11:44:00" itemprop="dateCreated datePublished" datetime="2021-11-26T11:44:00+08:00">2021-11-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础算法">基础算法</h2>
<h3 id="快速幂">快速幂</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll base, ll exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (exp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<p>给定长度为n的数组（<span class="math inline">\(n\geq 1\)</span>）</p>
<p>问题1：找到值为value的元素的下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 注意防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt; value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] &lt; value) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：找到<strong>第一个</strong>值为value的元素的下标</p>
<p>这时候遇到相等也不能直接返回，只能排除掉右侧的所有数。</p>
<p>数组的长度为 1 或 2 时，<code>middle</code>为 0. 若<code>array[0]</code>为要找的数，则<code>right</code>将被赋值为 -1，循环结束，<code>left</code>为答案。数组长度为 2 且<code>array[1]</code>为要找的数时，<code>left</code>将被赋值为 1，回到数组长度为 1 的情况。</p>
<p>因此最后再判断一下<code>left</code>是否为要找的数，如果是则返回，否则答案不存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt;= value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题3：找到<strong>最后一个</strong>值为value的元素的下标</p>
<p>这就是问题2的倒序版本。改动两个地方即可</p>
<ol type="1">
<li><p><code>if (array[middle] &gt;= value)</code> 中的等号去掉；</p></li>
<li><p><code>if (right &gt;= 0 &amp;&amp; array[right] == value) &#123;return right;&#125;</code></p></li>
</ol>
<p>问题4：找到<strong>第一个大于等于</strong>value的下标</p>
<p>在问题2中，我们的策略是让<code>left</code>刚好为第一个大于等于value的数的下标，而让<code>right</code>刚好为第一个小于value的数的下标。因此只需要去掉最后判断答案存在的<code>array[left] == value</code>条件即可。</p>
<p>问题5：找到<strong>最后一个小于等于</strong>value的下标</p>
<p>与问题4同理，去掉问题3中最后判断答案存在的<code>array[right] == value</code>条件。</p>
<h2 id="数论">数论</h2>
<h3 id="欧拉筛">欧拉筛</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辗转相除法求最大公因数greatest-common-divisor">辗转相除法求最大公因数（Greatest Common Divisor）</h3>
<p>最大公因数的算法是辗转相除法，基于一个原理：如果<span class="math inline">\(a&gt;b\)</span>则<span class="math inline">\(gcd(a,b)=gcd(b,a-b)\)</span>.</p>
<p>如果<span class="math inline">\(a-b&gt;b\)</span>，那么就继续相减到<span class="math inline">\(a-b&lt;b\)</span>为止，所以直接<span class="math inline">\(gcd(a,b)=gcd(b,a\bmod b)\)</span>.</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小公倍数least-common-multiple">最小公倍数（Least Common Multiple）</h3>
<p>两个数的最大公因数（Greatest Common Divisor）就是它们质因数的<strong>交集</strong>的乘积</p>
<p>考虑最小公倍数的性质。最小公倍数必须被<span class="math inline">\(a\)</span>或<span class="math inline">\(b\)</span>​整除，也就是说最小公倍数必须同时包含这两数的所有质因数，所以是它们质因数的<strong>并集</strong>的乘积。怎样得到这个乘积？<span class="math inline">\(a\times b\)</span>，然后容斥除掉共同的质因数<span class="math inline">\(gcd(a,b)\)</span>就好了。 <span class="math display">\[
lcm(a,b)=\dfrac{a\times b}{gcd(a,b)}
\]</span> 实际编程中一般先除后乘，防止溢出。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="裴蜀定理">裴蜀定理</h3>
<p>裴蜀定理，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。</p>
<p>其内容是：</p>
<p>设 <span class="math inline">\(a,b\)</span> 是不全为零的整数，则存在整数 <span class="math inline">\(x,y\)</span>, 使得 <span class="math inline">\(ax+by=\gcd(a,b)\)</span>.</p>
<h4 id="证明">证明：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数返回之前，存在<span class="math inline">\(b=0\)</span>. 这时显然有<span class="math inline">\(x=1,y=0\)</span>使得 <span class="math display">\[
a\cdot 1+0\cdot 0=gcd(a,0)
\]</span> 0 和任何数的最大公约数都等于原数。</p>
<p>当<span class="math inline">\(b&gt;0\)</span>时，有<span class="math inline">\(gcd(a,b)=gcd(b,a\bmod b)\)</span>. 假设存在<span class="math inline">\(x,y\)</span>使得 <span class="math display">\[
bx+(a\bmod b)y=gcd(b,a\bmod b)
\]</span> 且 <span class="math display">\[
a\bmod b=a-b\cdot \left\lfloor \dfrac{a}{b} \right\rfloor
\]</span> 所以 <span class="math display">\[
\begin{aligned}
bx+(a\bmod b)y&amp;=bx+\left(a-b\cdot \left\lfloor \dfrac{a}{b} \right\rfloor\right)y\\
&amp;=ay-b\left(x-\left\lfloor \dfrac{a}{b} \right\rfloor y\right )
\end{aligned}
\]</span> 令<span class="math inline">\(x&#39;=y,\ y&#39;=x-\left\lfloor \dfrac{a}{b} \right\rfloor y\)</span>，可得 <span class="math display">\[
ax&#39;+by&#39;=gcd(a,b)
\]</span> 用归纳法即可得证。</p>
<p>参考：https://www.cnblogs.com/fusiwei/p/11775503.html</p>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>为什么叫它扩展欧几里得呢？因为它就是在欧几里得算法（辗转相除法）求得<span class="math inline">\(gcd(a,b)\)</span>的基础上，像上面裴蜀定理的证明那样倒着回溯找了一组<span class="math inline">\(x,y\)</span>满足 <span class="math display">\[
ax+by=gcd(a,b)
\]</span> 具体代码请看下面的线性同余方程。</p>
<h3 id="线性同余方程线性丢番图方程">线性同余方程（线性丢番图方程）</h3>
<p>形如<span class="math inline">\(ax\equiv c\pmod b\)</span>的方程被称为线性同余方程 (Congruence Equation)。</p>
<h4 id="求解方法">求解方法</h4>
<p>根据以下两个定理，我们可以求出同余方程 <span class="math inline">\(ax \equiv c \pmod b\)</span> 的解。</p>
<p><strong>定理 1</strong>：方程 <span class="math inline">\(ax+by=c\)</span> 与方程 <span class="math inline">\(ax \equiv c \pmod b\)</span> 是等价的，有整数解的充要条件为 <span class="math inline">\(\gcd(a,b) \mid c\)</span>。</p>
<p>根据定理 1，方程 <span class="math inline">\(ax+by=c\)</span>，我们可以先用扩展欧几里得算法求出一组 <span class="math inline">\(x_0,y_0\)</span>，也就是 <span class="math inline">\(ax_0+by_0=\gcd(a,b)\)</span>，然后两边同时除以 <span class="math inline">\(\gcd(a,b)\)</span>，再乘 <span class="math inline">\(c\)</span>。然后就得到了方程 <span class="math inline">\(a\dfrac{c}{\gcd(a,b)}x_0+b\dfrac{c}{\gcd(a,b)}y_0=c\)</span>，然后我们就找到了方程的一个解。</p>
<p><strong>定理 2</strong>：若 <span class="math inline">\(\gcd(a,b)=1\)</span>，且 <span class="math inline">\(x_0\)</span>、<span class="math inline">\(y_0\)</span> 为方程 <span class="math inline">\(ax+by=c\)</span> 的一组解，则该方程的任意解可表示为：<span class="math inline">\(x=x_0+bt\)</span>，<span class="math inline">\(y=y_0-at\)</span>, 且对任意整数 <span class="math inline">\(t\)</span> 都成立。</p>
<p>根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解 <span class="math inline">\(x=(x \bmod t+t) \bmod t\)</span>，其中 <span class="math inline">\(t=\dfrac{b}{\gcd(a,b)}\)</span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> d = <span class="built_in">ex_gcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp - a / b * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">liEu</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d = <span class="built_in">ex_gcd</span>(a, b, x, y);</span><br><span class="line">  <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = c / d;</span><br><span class="line">  x *= k;</span><br><span class="line">  y *= k;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用-stl">常用 STL</h2>
<h3 id="比较两个-string-是否相等">比较两个 string 是否相等</h3>
<p><a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/string/string/compare/">std::string::compare</a></p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">string (1)</th>
<th><code>int compare (const string&amp; str) const noexcept;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">substrings (2)</td>
<td><code>int compare (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen = npos) const;</code></td>
</tr>
<tr class="even">
<td style="text-align: right;">c-string (3)</td>
<td><code>int compare (const char* s) const; int compare (size_t pos, size_t len, const char* s) const;</code></td>
</tr>
<tr class="odd">
<td style="text-align: right;">buffer (4)</td>
<td><code>int compare (size_t pos, size_t len, const char* s, size_t n) const;</code></td>
</tr>
</tbody>
</table>
<p>返回值</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>value</th>
<th>relation between <em>compared string</em> and <em>comparing string</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td>They compare equal</td>
</tr>
<tr class="even">
<td><code>&lt;0</code></td>
<td>Either the value of the first character that does not match is lower in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is shorter.</td>
</tr>
<tr class="odd">
<td><code>&gt;0</code></td>
<td>Either the value of the first character that does not match is greater in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is longer.</td>
</tr>
</tbody>
</table>
<h3 id="从容器中删除指定的元素">从容器中删除指定的元素</h3>
<p>从字符串中删除某些字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeCharsFromString</span><span class="params">( string &amp;str, <span class="keyword">char</span>* charsToRemove )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(charsToRemove); ++i ) &#123;</span><br><span class="line">      str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), charsToRemove[i]), str.<span class="built_in">end</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/algorithm/remove/">std::remove</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="function">ForwardIterator <span class="title">remove</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/11/13/weird-marks-in-advanced-mathematics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/13/weird-marks-in-advanced-mathematics/" class="post-title-link" itemprop="url">解读高等数学中那些难懂的符号</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-13 10:53:00" itemprop="dateCreated datePublished" datetime="2021-11-13T10:53:00+08:00">2021-11-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="微分符号和积分符号">微分符号和积分符号</h2>
<p>准备工作：</p>
<ul>
<li>了解极限的定义以及相关的无穷小等概念。</li>
<li>了解导数是什么。</li>
<li>了解极限运算法则和求导法则。</li>
<li>理解“微分是函数的线性近似”</li>
</ul>
<p>很多人都说《高等数学》难学，一部分缘于求极限、求导和积分是全新的、之前没有接触过的运算，要掌握和熟练运用需要不少苦功夫；另一部分就要归结于编书者用“惯例”来搪塞各种解释的高傲态度。</p>
<p>第二章中，先介绍导数，再介绍微分。这导致前面突然就冒出个<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>求导符号。然而介绍微分的时候又草草带过。基本上，书中是这样定义微分运算的：对函数<span class="math inline">\(y=f(x)\)</span>，如果<span class="math inline">\(x_0\)</span>和<span class="math inline">\(x_0+\Delta x\)</span>在定义域内且 <span class="math display">\[
\Delta y=f&#39;\left( x\right) \Delta x+o\left( \Delta x\right)
\]</span> 那么记作 <span class="math display">\[
\mathrm{d}y=A\Delta x.
\]</span> 并且通常把自变量<span class="math inline">\(x\)</span>的增量<span class="math inline">\(\Delta x\)</span>称为自变量的微分，记作<span class="math inline">\(\mathrm{d}x\)</span>，即<span class="math inline">\(\mathrm{d}x=\Delta x\)</span>. 所以函数<span class="math inline">\(y=f(x)\)</span>的微分记作 <span class="math display">\[
\mathrm{d}y=f&#39;(x)\mathrm{d}x.
\]</span> 嗯？这就结束了？</p>
<p>所以微分是什么呢？难道跟我们学的加减乘除一样，就是一个运算符号？</p>
<p>是，也不完全是。</p>
<p>回想书中前面的内容，我们一直把求导符号<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>称为“算子”。其实这个概念在第一章第一节早有介绍，只不过大部分人都会忽略：</p>
<blockquote>
<p>映射又称为<strong>算子</strong>。根据集合<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>的不同情形，在不同的数学分支中，映射又有不同的惯用名称。例如，从非空集<span class="math inline">\(X\)</span>到数集<span class="math inline">\(Y\)</span>的映射又称为<span class="math inline">\(X\)</span>上的<strong>泛函</strong>，从非空集<span class="math inline">\(X\)</span>到它自身的映射又称为<span class="math inline">\(X\)</span>上的<strong>变换</strong>，从实数集（或其子集）<span class="math inline">\(X\)</span>到实数集<span class="math inline">\(Y\)</span>的映射通常定义为<span class="math inline">\(X\)</span>上的<strong>函数</strong>。</p>
</blockquote>
<p>那么求导是怎样的一种映射？显然是一个原函数映射成一个导函数。那微分呢？ <span class="math display">\[
\begin{align}
y&amp;=x^2\\
\mathrm{d}y&amp;=2x\mathrm{d}x
\end{align}
\]</span> 是函数映射成函数吗？看着不像啊！这怎么又有<span class="math inline">\(x\)</span>又有<span class="math inline">\(\mathrm{d}x\)</span>，难道是二元函数？</p>
<p>你可以这么理解，但是我认为一个（在数学上是等价的）更好的理解是：对于每一个<span class="math inline">\(x\)</span>，都有一个对应的函数<span class="math inline">\(g(\mathrm{d}x)=2x\mathrm{d}x\)</span>. 这个函数是<span class="math inline">\(y\)</span>在<span class="math inline">\(x\)</span>附近的<strong>线性近似</strong>。微分就是把一个函数映射到这样一个实数到函数的映射（若嫌麻烦也可以理解成二元函数）上面。</p>
<p>到这里，有必要解释一下为啥书里面不先介绍微分了。这其实是个历史遗留问题。微分的符号<span class="math inline">\(\mathrm{d}\)</span>最早是莱布尼茨发明的（顺便一提，积分符号也是他发明的），他把<span class="math inline">\(\Delta x\)</span>和<span class="math inline">\(\Delta y\)</span>当成是有限的增量，对应的<span class="math inline">\(\mathrm{d}x\)</span>和<span class="math inline">\(\mathrm{d}y\)</span>就是无穷小增量。然而麻烦的是，莱布尼茨对于无穷小和微分的定义是很不精确的（莱布尼茨发明微积分的时候还没有极限的严格定义，具体可以参考<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/21199/is-frac-textrmdy-textrmdx-not-a-ratio">这里的回答</a>），所以我们现在学习的<strong>并不是他的理论</strong>。然而我们要学他的符号，因为这已经是“惯例”了。我们学习的是 <span class="math display">\[
\dfrac{\mathrm{d}}{\mathrm{d}x}y=\lim _{\Delta x\to 0}{\frac {\Delta y}{\Delta x}}
\]</span> 其中<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>就是一个写得比较奇怪的记号。那么你可能会问：先讲微分，不就没这么多破事了吗？不好意思，不行。因为我们现在采用的是柯西给出的微积分定义（极限的严格定义也是柯西给出的）。他是用导数定义微分的： <span class="math display">\[
\mathrm{d}y=f&#39;(x)\mathrm{d}x.
\]</span> 这下死循环了。所以编书者没办法，就这么将就学吧。</p>
<p>有人会问：不是说牛顿和莱布尼茨同时发明了微积分吗？牛顿的符号为啥没流传下来呢？其实现在也在用，就是<span class="math inline">\(\dot {y}\)</span>，表示<span class="math inline">\(y\)</span>的一阶导数，二阶就是加两个点，三阶就是加三个点，以此类推。但是这样写并没有显式地指明自变量是什么，容易造成误解。</p>
<p>莱布尼茨符号流行的另外一个原因是它能辅助记忆用于微分和积分的公式。比如链式法则：假设函数<span class="math inline">\(g\)</span>在<span class="math inline">\(x\)</span>处可微，<span class="math inline">\(y = f(u)\)</span>在<span class="math inline">\(u = g(x)\)</span>处可微。那么复合函数<span class="math inline">\(y = f(g(x))\)</span>在<span class="math inline">\(x\)</span>处是可微的，其导数用莱布尼茨符号表示为： <span class="math display">\[
\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\cdot \dfrac{\mathrm{d}u}{\mathrm{d}x}
\]</span> 把<span class="math inline">\(\mathrm{d}u\)</span>消……等等！谁告诉你能这么消的？ <span class="math display">\[
\dfrac{\mathrm{d}y}{\mathrm{d}x}=\lim _{\Delta u\to 0}{\frac {\Delta y}{\Delta u}} \cdot \lim _{\Delta x\to 0}{\frac {\Delta u}{\Delta x}}
\]</span> 用极限形式写出来。显然，这两个极限的变量都不一样，不可以消去。</p>
<p>如果要证明链式法则，我们可以利用微分的概念。 <span class="math display">\[
\begin{align}
\Delta y&amp;=f&#39;(u)\Delta u+o(\Delta u)\\
&amp;=f&#39;(u)\left[g&#39;(x)\Delta x+o(\Delta x)\right]+o(\Delta u)\\
&amp;=f&#39;(u)g&#39;(x)\Delta x+f&#39;(u)\cdot o(\Delta x)+o(\Delta u)
\end{align}
\]</span> 所以 <span class="math display">\[
\mathrm{d}y=f&#39;(u)\mathrm{d}u=f&#39;(u)g&#39;(x)\mathrm{d}x
\]</span> 书中用导数定义微分，因此复合函数的微分法则就是由链式法则推出。但是我个人感觉这样的写法更自然好懂：既然我要的是线性近似，那么自变量<span class="math inline">\(u\)</span>当然也可以被它自己的线性近似替代。</p>
<p>有了链式法则，我们就有了<strong>一阶微分形式不变性</strong>：对于上面的自变量的微分<span class="math inline">\(\mathrm{d}u\)</span>，我们原先把它看作自变量的增量<span class="math inline">\(\Delta u\)</span>，但是现在我们发现如果<span class="math inline">\(u\)</span>又作为另外一个函数<span class="math inline">\(g\)</span>的因变量，<span class="math inline">\(\mathrm{d}u\)</span>可以直接被替换成它求微分的结果<span class="math inline">\(g&#39;(x)\mathrm{d}x\)</span>.</p>
<p>那既然对谁微分都是一样的形式，岂不是自变量就不重要了？所以<span class="math inline">\(\mathrm{d}\)</span>无论出现在哪里都是一个意思，无论<span class="math inline">\(y\)</span>对应的自变量是<span class="math inline">\(x\)</span>还是<span class="math inline">\(v\)</span>？</p>
<p>错。我们上面说的微分形式不变性是对于<strong>一阶微分</strong>而言的，对于二阶微分会是什么样的情况呢？</p>
<p>对于二阶导数，书中是这么写的 <span class="math display">\[
f&#39;&#39;(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}\left(\dfrac{\mathrm{d}y}{\mathrm{d}x}\right)=\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}
\]</span></p>
<p>看着也挺怪的，我们用微分写 <span class="math display">\[
\begin{align}
\mathrm{d}^2y&amp;=\mathrm{d}(\mathrm{d}y)\\
&amp;=\mathrm{d}(f&#39;(x)\mathrm{d}x)\\
&amp;=\mathrm{d}(f&#39;(x))\mathrm{d}x+f&#39;(x)\mathrm{d}(\mathrm{d}x)\\
&amp;=(f&#39;&#39;(x)\mathrm{d}x)\mathrm{d}x+f&#39;(x)\mathrm{d}^2x\\
&amp;=f&#39;&#39;(x)\mathrm{d}x^2+f&#39;(x)\mathrm{d}^2x
\end{align}
\]</span></p>
<p>好像多了一项<span class="math inline">\(f&#39;(x)\mathrm{d}^2x\)</span>？</p>
<p>这就是为什么微分形式不变性对于二阶微分不成立！二阶微分不但会受<span class="math inline">\(\mathrm{d}x^{2}\)</span>影响，也会受<span class="math inline">\(\mathrm{d^2}x\)</span>影响。</p>
<p>我们若是想得到二阶导数的形式，就必须把<span class="math inline">\(x\)</span><strong>看成自变量而不是一个可微的函数</strong>，我们实际上求的是对<span class="math inline">\(\mathrm{d}x\)</span>的偏微分</p>
<p><span class="math display">\[
\left(\partial ^ 2 y\right) _ {\mathrm{d}x}=f&#39;&#39;(x)\mathrm{d}x^2
\]</span></p>
<p>所以，二阶微分不具有形式不变性。</p>
<p>现在来说积分。这里直接跳过书上的“记作”论调，重新定义：积分就是微分的<strong>逆运算</strong>。回想起我们对微分的理解：微分就是把一个函数映射到一个“实数到函数的映射”（若嫌麻烦也可以理解成二元函数）上面。那么积分就是微分的<strong>逆映射</strong>。给一个实数到函数的映射（二元函数），就能对应回一个函数上。嗯？等等，微分这个映射并不是单射，不同的函数也可能有相同的微分。那怎么办呢？我们给它打个补丁：由于有相同微分的原函数互相都只相差某个常数，我们就把积分定义成一个实数到函数的映射对应一个函数集合。这个函数集合中的函数互相都只相差某个常数，我们就用<span class="math inline">\(F(x)+C\)</span>来表示这个函数集合。</p>
<p>从定义立即可以得到，如果在区间<span class="math inline">\(I\)</span>上可导函数<span class="math inline">\(F(x)\)</span>的导函数为<span class="math inline">\(f(x)\)</span>，对任一<span class="math inline">\(x\in I\)</span>，都有 <span class="math display">\[
\int \mathrm{d}F(x)=\int f(x)\mathrm{d}x=F(x)+C.
\]</span> 回到上面的复合函数，如果<span class="math inline">\(f(u)\)</span>具有原函数<span class="math inline">\(F(u)\)</span>，由微分形式不变性，有 <span class="math display">\[
\int f(g(x))g&#39;(x)\mathrm{d}x=\int f&#39;(u)\mathrm{d}u=F(u)+C
\]</span> 这就是换元积分法中的<strong>第一类换元法</strong>。其实，这就是对被积表达式部分积分。</p>
<p>我们也可以反向操作：</p>
<p>令<span class="math inline">\(t=\phi ^{-1}(x)\)</span>，则<span class="math inline">\(x=\phi (t)\)</span>，有 <span class="math display">\[
\int f(x)\mathrm{d}x=\int f(\phi (t))\mathrm{d}\phi (t)=\int f(\phi (t))\phi &#39;(t)\mathrm{d}t
\]</span> 这就是换元积分法中的<strong>第二类换元法</strong>。</p>
<p>微分法则能启发我们计算积分，比如：对于在区间<span class="math inline">\(I\)</span>上的可微函数<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g(x)\)</span>有 <span class="math display">\[
\begin{aligned}
\mathrm{d}\left[f(x)g(x)\right]&amp;=f(x)\cdot \mathrm{d}g(x)+\mathrm{d}f(x)\cdot g(x)\\
&amp;=f(x)g&#39;(x)\mathrm{d}x+f&#39;(x)g(x)\mathrm{d}x
\end{aligned}
\]</span> 两边积分得 <span class="math display">\[
\int \mathrm{d}\left[f(x)g(x)\right]=\int f(x)g&#39;(x)\mathrm{d}x+\int f&#39;(x)g(x)\mathrm{d}x
\]</span> 即 <span class="math display">\[
\int f(x)g&#39;(x)\mathrm{d}x=f(x)g(x)-\int f&#39;(x)g(x)\mathrm{d}x
\]</span> 这就是<strong>分部积分法</strong>。也可以写成简洁形式 <span class="math display">\[
\int u\mathrm{d}v=uv-\int v\mathrm{d}u
\]</span> 如果你想要理解这些积分法则，这里有一个线索：第一、第二类换元法对应的是复合函数，分部积分法对应的是两个函数的乘积运算。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qW411N7FU?p=4">这个视频</a> 也许也能帮助你更直观地理解。</p>
<p>学积分的时候应该注意思考积分法则的逆运算（逆操作）是什么。如果能明白简单的积分形式是怎么变复杂的，看到复杂的积分也就不难化简了。上面这三种积分法则的逆运算是什么呢？</p>
<p>很容易发现第一类、第二类换元法是互为逆运算的。而分部积分法的逆运算是它自己 <span class="math display">\[
\int u\mathrm{d}v=uv-\int v\mathrm{d}u=uv-\left(uv- \int u\mathrm{d}v \right)=\int u\mathrm{d}v
\]</span></p>
<p><strong>References:</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/li-hua/p/6617366.html">迷之记号 dx 到底是什么鬼</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30296338/answer/120574352">什么是微分形式不变性？一阶微分形式不变性与链式法则是等价的吗（两者可互推？）？两者有什么区别？ - 马同学的回答</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26490937">微分符号 dx、dy 表示什么含义？</a></li>
<li><a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/21199/is-frac-textrmdy-textrmdx-not-a-ratio">Is d/dx not a ratio?</a></li>
<li><a target="_blank" rel="noopener" href="https://math.stackexchange.com/a/3561534/858590">The second differential versus the differential of a differential form</a></li>
</ol>
<h2 id="积分中的魔法">积分中的魔法</h2>
<p>积分有什么用呢？</p>
<p>要解释积分的用途，我们要提一个很经典的问题：求曲边梯形的面积。也就是说，我们想知道由两条垂直于<span class="math inline">\(x\)</span>轴的直线，一条函数曲线<span class="math inline">\(y = f(x)\)</span>和<span class="math inline">\(x\)</span>轴围成区域的面积。</p>
<p>首先我们得岔开话题，先讲积分的一个有趣的性质。</p>
<p>我们学过拉格朗日中值定理（均值定理）：函数<span class="math inline">\(f(x)\)</span>若在<span class="math inline">\([a,b]\)</span>内连续，<span class="math inline">\((a,b)\)</span>内可导，存在<span class="math inline">\(\xi \in (a,b)\)</span>使 <span class="math display">\[
f(b)-f(a)=f&#39;( \xi )(b-a)
\]</span> 我们可以尝试把这个定理应用到原函数<span class="math inline">\(F(x)\)</span>上 <span class="math display">\[
F(b)-F(a)=F&#39;( \xi )(b-a)=f( \xi )(b-a)
\]</span> 等式右边是什么意思呢？它看着像是长为<span class="math inline">\(f(\xi )\)</span>宽为<span class="math inline">\(b-a\)</span>的长方形的面积。</p>
<p>微积分的核心思想之一，是把宏观的、难以解决的问题转化为很多局部的、近似的问题。</p>
<p>我们可以这么写 <span class="math display">\[
F(x+\Delta x)-F(x)=f( \xi )\Delta x
\]</span> 等式右边的意思是说，在一个很小的宽为<span class="math inline">\(\Delta x\)</span>的区间内，其中一点<span class="math inline">\(\xi\)</span>的函数值为长，<span class="math inline">\(\Delta x\)</span>为宽围成的面积。</p>
<p>微积分的核心思想之二是极限。在不断趋近的过程中证明要多近有多近。</p>
<p>在这里我们首先要做的是趋近。证明当<span class="math inline">\(\Delta x \to 0\)</span>时<span class="math inline">\(f( \xi )\Delta x\)</span>可以任意的接近<span class="math inline">\(\Delta x\)</span>为宽的那个区间内的曲边梯形面积。也就是说 <span class="math display">\[
\Delta A=\lim_{\Delta x \to 0}{f( \xi )\Delta x}
\]</span> 好吧，这个证明有点冗长，有时间再补。</p>
<p>下一步，就是积。把区间<span class="math inline">\([a,b]\)</span>分成<span class="math inline">\(n\)</span>份，每一份的宽度为<span class="math inline">\(\Delta x = \frac{b-a}{n}\)</span>，左右端点为<span class="math inline">\([x_{i-1},x_i]\)</span>，有 <span class="math display">\[
F(x_n)-F(x_{n-1})+F(x_{n-1})-F(x_{n-2})+\cdots+F(x_1)-F(x_0)=\sum ^{n}_{i=1}\left[f\left( \xi _{i}\right) \Delta x \right]
\]</span> 这时候，奇迹发生了： <span class="math display">\[
F(x_n)-F(x_0)=F(b)-F(a)=\sum ^{n}_{i=1}\left[ f\left( \xi _{i}\right) \Delta x \right]
\]</span> 左边中间的项全部被消掉，这时候我们发现，等式左边跟<span class="math inline">\(n\)</span><strong>无关</strong>了。也就是说，我们可以自信地写下 <span class="math display">\[
F(b)-F(a)=\lim_{n\to \infty}{\sum ^{n}_{i=1}{\frac{f\left( \xi _{i}\right) (b-a)}{n}}}=\lim_{n\to \infty}{\sum ^{n}_{i=1}{\Delta A_i}}=A
\]</span> 原本看上去不可能的问题，就这么被轻易解决了。</p>
<p>由于很多问题都可以用类似求曲边梯形的方法解答，我们专门给<span class="math inline">\(F(b)-F(a)\)</span>分配了符号，并称之为<span class="math inline">\(f(x)\)</span>在区间<span class="math inline">\([a,b]\)</span>上的<strong>定积分</strong>： <span class="math display">\[
\int_{a}^{b} f(x)\mathrm{d}x=F(b)-F(a)
\]</span> 上面的性质也成了积分中值定理 <span class="math display">\[
\int_{a}^{b} f(x)\mathrm{d}x=f( \xi )(b-a)
\]</span></p>
<h2 id="从等价无穷小到泰勒公式">从等价无穷小到泰勒公式</h2>
<h3 id="启程">启程</h3>
<p>在第 1.7 节 无穷小的比较中就介绍了等价无穷小：</p>
<blockquote>
<p>如果 <span class="math inline">\(\lim \dfrac{\beta}{\alpha}=1\)</span>，那么就说 <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\alpha\)</span> 是等价无穷小，记作 <span class="math inline">\(\alpha \sim \beta\)</span>.</p>
</blockquote>
<p>比如 <span class="math display">\[
\sin x \sim x \ (x\to 0)
\]</span> 等价无穷小有什么特别的，以至于要专门给他分配个符号呢？</p>
<p>由极限运算法则，如果 <span class="math inline">\(\lim f(x)=A\)</span>，<span class="math inline">\(\lim g(x)=B\)</span>，那么 <span class="math display">\[
\lim[f(x)\cdot g(x)]=\lim f(x)\cdot \lim g(x)=A\cdot B
\]</span> 所以 <span class="math display">\[
\lim_{x\to 0} f(x) = \lim_{x\to 0} f(x) \cdot \lim_{x\to 0}\dfrac{\sin x}{x} = \lim_{x\to 0} \left[ f(x) \cdot \dfrac{\sin x}{x} \right]
\]</span> 来看个实际用例： <span class="math display">\[
\lim _{x\rightarrow 0}\dfrac{\sin x}{x^{3}+3x}=\lim _{x\rightarrow 0}\left( \dfrac{\sin x}{x^{3}+3x}\cdot \dfrac{x}{\sin x}\right) = \lim _{x\rightarrow 0}\dfrac{x}{x(x^{2}+3)} = \dfrac{1}{3}
\]</span> 常用的等价无穷小还有 <span class="math display">\[
\begin{aligned}
e^x-1&amp;\sim x\ (x\to 0)\\
\ln (1+x)&amp;\sim x\ (x\to 0)
\end{aligned}
\]</span></p>
<h3 id="岔路">岔路</h3>
<p>过了一段时间，你学到了拉格朗日中值公式。如果（省略）则 <span class="math display">\[
f(b)-f(a)=f&#39;( \xi )(b-a)
\]</span> 回到上面那个实际用例。我们可以说，由 <span class="math inline">\(\sin x\)</span> 在 <span class="math inline">\(x=0\)</span> 的某一去心邻域内可导，所以存在 <span class="math inline">\(\xi \in \mathring{U}(0,x)\)</span> 使得 <span class="math display">\[
\sin x-\sin 0=\cos \xi(x-0)
\]</span> 当 <span class="math inline">\(x\to 0\)</span> 时有 <span class="math display">\[
\lim_{x\to 0}\dfrac{\sin x}{x}=\lim_{x\to 0}\dfrac{\sin x-\sin 0}{x-0}=\lim_{x\to 0}\cos \xi=1
\]</span> 看起来有点意思？还有更有意思的。</p>
<p>如果 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\(a\)</span> 的某去心邻域内可导，当 <span class="math inline">\(x\to a\)</span> 时函数 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 都趋于零，对于下面这个极限 <span class="math display">\[
\lim_{x\to a}\frac{f(x)}{g(x)}
\]</span> 我们可以把上面的方法同时应用到分子分母上。我们为了连续性假定 <span class="math inline">\(f(a)=g(a)=0\)</span> 则此时两函数在 <span class="math inline">\(a\)</span> 的某邻域内连续。</p>
<p>存在 <span class="math inline">\(\xi_1 \in \mathring{U}(a,x), \xi_2 \in \mathring{U}(a,x)\)</span>​ 使得 <span class="math display">\[
\begin{aligned}
f(x)-f(a)&amp;=f&#39;(\xi_1)(x-a)\\
g(x)-g(a)&amp;=g&#39;(\xi_2)(x-a)
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(g&#39;(x)\neq 0\)</span>，有 <span class="math display">\[
\lim_{x\to a}\dfrac{f(x)}{g(x)}=\lim_{x\to a}\dfrac{f(x)-f(a)}{g(x)-g(a)}=\lim_{x\to a}\frac{f&#39;(\xi_1)(x-a)}{g&#39;(\xi_2)(x-a)}=\lim_{x\to a}\frac{f&#39;(x)}{g&#39;(x)}
\]</span> 洛必达法则！实际上证明洛必达法则并不依赖柯西中值定理。</p>
<p>上面的推导启示我们，洛必达法则和等价无穷小有某种意义上的联系。若函数 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\(x=x_0\)</span> 的某邻域内 <span class="math inline">\(n\)</span> 阶可导，且当 <span class="math inline">\(x\to x_0\)</span> 时 <span class="math inline">\(f(x)\sim g(x)\)</span> 则 <span class="math display">\[
\lim_{x\to x_0}\dfrac{f(x)}{g(x)}=\lim_{x\to x_0}\frac{f^{(n)}(x)}{g^{(n)}(x)}=1
\]</span> 另外，在这个过程中你可能会发现 <span class="math display">\[
\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(\xi_1)(b-a)}{g&#39;(\xi_2)(b-a)}=\frac{f&#39;(\xi_1)}{g&#39;(\xi_2)}
\]</span> 柯西中值定理？其实并不是，柯西中值定理还需要 <span class="math inline">\(\xi_1=\xi_2\)</span>​，构造 <span class="math display">\[
h(x) = [f(x) - f(a)][g(b) - g(a)] - [g(x) - g(a)][f(b) - f(a)].
\]</span> 显然 <span class="math inline">\(h(a)=h(b)=0\)</span>​，由罗尔中值定理得 <span class="math display">\[
0 = h&#39;(\xi) = f&#39;(\xi)(g(b) - g(a)) - g&#39;(\xi)(f(b) - f(a))
\]</span></p>
<p>为什么同济高数书上要写成这么别扭的样子呢？ <span class="math display">\[
h(x)=f(x)-\frac{f(b)-f(a)}{g(b)-g(a)}g(x)
\]</span> 我猜大概是为了强调 <span class="math inline">\(g(b)-g(a)\neq 0\)</span> 吧（由 <span class="math inline">\(g&#39;(x)\neq 0\)</span> 推出）</p>
<p>再来看一个洛必达法则的证明：</p>
<p>若 <span class="math inline">\(f, g : (a, b) \to R\)</span> 在 <span class="math inline">\(x_0 \in (a,b)\)</span> 上可导，且 <span class="math inline">\(f(x_0)=g(x_0)=0\)</span>，<span class="math inline">\(g&#39;(x_0)\neq 0\)</span>. 则 <span class="math display">\[
\frac{f&#39;(x_0)}{g&#39;(x_0)}=\frac{\lim_{x\to x_0}{\frac{f(x)-f(x_0)}{x-x_0}}}{\lim_{x\to x_0}{\frac{g(x)-g(x_0)}{x-x_0}}}=\lim_{x\to x_0}{\frac{f(x)-f(x_0)}{g(x)-g(x_0)}}=\lim_{x\to x_0}{\frac{f(x)}{g(x)}}
\]</span> 这就证完了？能用一行证明，为什么上面要绕一大圈？</p>
<p>请注意洛必达法则的条件</p>
<blockquote>
<ol type="1">
<li>当 <span class="math inline">\(x\to x_0\)</span> 时，函数 <span class="math inline">\(f(x)\)</span> 及 <span class="math inline">\(g(x)\)</span> 都趋于零.</li>
<li>在点 <span class="math inline">\(x_0\)</span> 的<strong>某去心邻域内</strong>，<span class="math inline">\(f&#39;(x)\)</span> 及 <span class="math inline">\(g&#39;(x)\)</span> 都存在且 <span class="math inline">\(g&#39;(x)\neq 0\)</span>.</li>
<li><span class="math inline">\(\lim_{x\to x_0}{\frac{f&#39;(x)}{g&#39;(x)}}\)</span> 存在（或为无穷大）.</li>
</ol>
</blockquote>
<p>其中第 1、2 点都不一样，但是证明时假定了 <span class="math inline">\(f(x_0)=g(x_0)=0\)</span> 所以实际上第 1 点没有区别。最关键的是第 2 点：<span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 只需要在 <span class="math inline">\(x_0\)</span> 的某去心邻域可导，不需要在 <span class="math inline">\(x_0\)</span> 可导。与之相对应，公式中也是取两函数导数的比值的极限。</p>
<h3 id="迷途">迷途</h3>
<p>我们来看一道 经 典 例 题： <span class="math display">\[
\lim_{x\to0}\left(\frac{e^x +xe^x}{e^x-1}-\frac{1}{x}\right)
\]</span> 你可能会这么写： <span class="math display">\[
\begin{aligned}
\lim_{x\to 0}\left(\frac{e^x +xe^x}{e^x-1}-\frac{1}{x}\right)&amp;=\lim_{x\to 0}\frac{e^x +xe^x}{e^x-1} - \lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\frac{e^x +xe^x}{e^x-1}\times \lim_{x\to 0}\frac{e^x-1}{x}-\lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\left(\frac{e^x +xe^x}{e^x-1} \times \frac{e^x-1}{x}\right)-\lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\left(\frac{e^x +xe^x}{x}-\frac{1}{x}\right) \\
&amp;=\lim_{x\to 0}\frac{e^x +xe^x-1}{x} \\
&amp;=\lim_{x\to 0}\left(2e^x-xe^x\right) \\
&amp;=2
\end{aligned}
\]</span></p>
<p>然而！答案是 <span class="math inline">\(\frac{2}{3}\)</span>.</p>
<p>错在哪呢？其实第一步就错了，拆出来成了 <span class="math inline">\(\infty -\infty\)</span>，而极限运算法则<strong>只在两极限存在时才成立</strong>，不能拆。如果你不是这么做的但是得到了错误的结果，请自行根据 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62029838">这篇文章</a> 对号入座。</p>
<p>辅导书和老师可能会告诉你，等价无穷小的用法仅限于极限值整体乘以 1 再代换！这种说法确实没错，但是事情是不是就这么简单地结束了呢？为什么有的情况下替换不会出现问题呢？</p>
<p>请看同济高数第 1-7 节定理 1: <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\alpha\)</span> 是等价无穷小的充分必要条件为 <span class="math display">\[
\beta=\alpha + o(\alpha)
\]</span> 可以看出，两个等价无穷小之间差了一个高阶无穷小。那么什么时候不能用等价无穷小呢？</p>
<p>就是除了无穷小以外的量全部都被消去的情况，这时候高阶无穷小才会左右极限的结果，而它会受到等价无穷小替换的影响而不准确。</p>
<p>也就是说</p>
<blockquote>
<p>已知 <span class="math inline">\(\lim_{x\to x_0}{\frac{\alpha_1}{\alpha_2}}\)</span> 存在， <span class="math inline">\(\alpha_1,\alpha_{2},\beta_{1},\beta_{2}\)</span> 都是 <span class="math inline">\(x\rightarrow x_0\)</span> 的无穷小量，且 <span class="math inline">\(\alpha_1\sim\beta_1\)</span>，<span class="math inline">\(\alpha_{2}\sim\beta_{2}\)</span>.</p>
<p>若 <span class="math inline">\(\lim_{x\rightarrow x_0}{\frac{\alpha_1}{\alpha_2}} \neq 1\)</span> （两者的泰勒展开的第一项不相同），则 <span class="math inline">\(\alpha_1-\alpha_2\sim \beta_1-\beta_2\)</span>;</p>
<p>若 <span class="math inline">\(\lim_{x\rightarrow x_0}{\frac{\alpha_1}{\alpha_2}} \neq -1\)</span>（两者的泰勒展开的第一项不互为相反数），则 <span class="math inline">\(\alpha_1+\alpha_2\sim\beta_1+\beta_2\)</span>.</p>
</blockquote>
<h3 id="终点">终点</h3>
<p>上面看似已经把等价无穷小的用法说清楚了，但是还有很多隐藏的问题。比如说，极限运算法则必须要两个极限存在才成立，那么如果我要求的极限本来就不存在呢？难道我每次用之前还要证明这个极限存在？</p>
<p>所以我们不如用回等价无穷小的充要条件 <span class="math display">\[
\alpha \sim \beta \Leftrightarrow \beta=\alpha + o(\alpha)
\]</span> 等价替换永远是最直接、最少出错的。</p>
<p>而实际上我们用等价无穷小的时候几乎从来都是换成多项式函数，因为它好化简、好求极限。</p>
<p>又过了一段时间，你学到了泰勒公式，它是拉格朗日中值公式的推广（令 <span class="math inline">\(n=2m\)</span>） <span class="math display">\[
\begin{align}
\sin \left(x\right)&amp;= x-{\frac {x^{3}}{3!}}+{\frac {x^{5}}{5!}}-{\frac {x^{7}}{7!}}+\cdots +(-1)^{m-1}\dfrac{x^{2m-1}}{(2m-1)!}+o(x^{2m})\\
e^{x}&amp;=1+x+{\frac {x^{2}}{2!}}+{\frac {x^{3}}{3!}}+\cdots +\frac{x^{n-1}}{(n-1)!} +o(x^n)\\
\ln(1+x)&amp;=x-{\frac {x^{2}}{2}}+{\frac {x^{3}}{3}}-\cdots+(-1)^{n-1}\dfrac{1}{n}x^n+o(x^n)
\end{align}
\]</span></p>
<p>接下来不用多说了吧。<strong>用泰勒公式，别用等价无穷小。</strong></p>
<p>后记：这篇文章写的很混乱，中途删了又写，写了又删。最后终于在高数期末考前仓促结尾，行文思路混乱，更别说严谨性。现在回头反思，总感觉自己太过于相信自己的所谓直觉，推导一番后又发现和目标不搭边。总结：想的太多，读的太少，算的更少。</p>
<p><strong>References:</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://www.math.pitt.edu/~sparling/23012/23012lhopital1/node1.html">Cauchy's Mean Value Theorem and L'Hopital's rule</a></li>
<li><a target="_blank" rel="noopener" href="https://home.iitk.ac.in/~psraj/mth101/lecture_notes/lecture7.pdf">(PDF)Lecture 7 : Cauchy Mean Value Theorem, L'Hospital Rule</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62029838">高数常见坑点：等价无穷小</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99373470">“等价无穷小量的替换”的详析 - 李亦督的文章 - 知乎</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/10/10/algorithm-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/10/algorithm-notes/" class="post-title-link" itemprop="url">算法学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-10 07:08:00" itemprop="dateCreated datePublished" datetime="2021-10-10T07:08:00+08:00">2021-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>学习算法的过程中看题解是很重要的一环，但往往题解只提供一种解法，角度难免片面。因此这里主要以题目为中心，整理我看到的各种解法以及一些个人感想。</p>
<h2 id="p1115-最大子段和">P1115 最大子段和</h2>
<p>这题贪心应该是最直接的方法，也同时可以用前缀和的思想做。</p>
<p>题目要求的是选连续的一段，而且不限制长度，如果我们又枚举起点又枚举长度就会 <span class="math inline">\(O(n^2)\)</span> .</p>
<p>起点不确定的情况不好控制，我们可以把子段和转化成：第 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(x\)</span> 个数之和减去第 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(y\)</span> 个数之和，其中 <span class="math inline">\(x &gt; y\)</span> . 对于每一个 <span class="math inline">\(x\)</span> ，问题就转换成了求最小前缀和。时间复杂度 <span class="math inline">\(O(n)\)</span>.</p>
<p>贪心就更直接了。设当前以第 <span class="math inline">\(i\)</span> 个数结尾的子段最大和为 <span class="math inline">\(dp[i]\)</span> ，我们可以看出若是 <span class="math inline">\(dp[i - 1] + a[i] &lt; 0\)</span>，我们就还不如不选第 <span class="math inline">\(i\)</span> 个数，直接 <span class="math inline">\(dp[i] = 0\)</span> 即可。其他情况下就必然是 <span class="math inline">\(dp[i] = dp[i - 1] + a[i]\)</span>. 最后找出最大的 <span class="math inline">\(dp[i]\)</span> 就可以了。由于 <span class="math inline">\(dp[i]\)</span> 可以直接由一个变量存储，空间复杂度 <span class="math inline">\(O(1)\)</span>. 时间复杂度 <span class="math inline">\(O(n)\)</span>.</p>
<h2 id="cf1573b-swaps">CF1573B Swaps</h2>
<p>这题看起来很复杂，其实就一个关键点：<span class="math inline">\(a\)</span> 都为奇数而 <span class="math inline">\(b\)</span> 都为偶数，因此这两个数组从第一个数开始就不一样。想让 <span class="math inline">\(a\)</span> 字典序小于 <span class="math inline">\(b\)</span> 的话，就需要且仅需要 <span class="math inline">\(a_1&lt;b_1\)</span>. 所以只要找到一对 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_j\)</span> 满足 <span class="math inline">\(a_i&lt;b_j\)</span> 并一个一个把这两个数分别移到最前面就好了。此时问题就转化为找最小的 <span class="math inline">\(i+j-2\)</span>. （若下标从 <span class="math inline">\(0\)</span> 开始则为最小的 <span class="math inline">\(i+j\)</span>）</p>
<p>假设我们一定要选某个 <span class="math inline">\(b\)</span> 中的偶数 <span class="math inline">\(b_j\)</span>，此时我们只需要找满足 <span class="math inline">\(a_i&lt;b_j\)</span> 的下标最小的 <span class="math inline">\(a_i\)</span> 即为最优解。因此我们可以这样做：开一个数组 <span class="math inline">\(p\)</span> 记录某个数 <span class="math inline">\(n\)</span> 在数组 <span class="math inline">\(a/b\)</span> 中的位置 <span class="math inline">\(p_n\)</span>. 从大到小遍历所有的数，然后用一个变量 <span class="math inline">\(l\)</span> 记录当前遍历到的 <span class="math inline">\(a\)</span> 中最小的下标，若当前数 <span class="math inline">\(n\)</span> 为奇数则 <span class="math inline">\(l=min(l, p_n)\)</span>，若当前为偶数则更新答案为 <span class="math inline">\(min(answer, p_n + l)\)</span>. （注意这里认为下标从 <span class="math inline">\(0\)</span> 开始）</p>
<h2 id="abc223b-string-shifting">ABC223B String Shifting</h2>
<p>不知道是不是受到之前做的一道很类似的题的影响，这题想了很久很久。</p>
<p>首先分析问题：题目中的平移可等价为把字符串的前<span class="math inline">\(n\)</span>个字符移到最后或者把字符串的后<span class="math inline">\(n\)</span>个字符移到最前。那么我们首先会发现把前<span class="math inline">\(n\)</span>个字符移动到最后等价于把后<span class="math inline">\(length-n\)</span>个字符移动到最前，我们只用关心移动到最前（或最后）的情况。由于每次只能操作最后的<span class="math inline">\(n\)</span>个字符，无论操作多少次都可等价于操作一次。那么问题转化为：</p>
<blockquote>
<p>给定非空字符串<span class="math inline">\(S\)</span>，选择<span class="math inline">\(S\)</span>的后<span class="math inline">\(n\)</span>个字符移动到首端。分别求移动后使得<span class="math inline">\(S\)</span>字典序最大和最小的<span class="math inline">\(n\)</span>。</p>
</blockquote>
<p>剩下的就很简单了：鉴于<span class="math inline">\(n\leq1000\)</span>，我们直接枚举所有可能的<span class="math inline">\(n\)</span>，把最大的和最小的找出来就好了。（然而因为没注意到这个题允许<span class="math inline">\(O(n^2)\)</span>时间复杂度我卡了1hr多）</p>
<h2 id="年广东工业大学新生赛-f-失踪的玫瑰">2019年广东工业大学新生赛 F 失踪的玫瑰</h2>
<p>参考：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/352755">【题解】2019年广东工业大学腾讯杯新生程序设计竞赛</a></p>
<p>题面可以等价转换为：有<span class="math inline">\(n\)</span>个山洞，初始状态下每个山洞里都有一只狐狸，每天晚上每只没抓住的狐狸都会分身去两边的洞，每天白天都有一个猎人去查看一个山洞，求抓住全部狐狸的方案数。以下用x代表一定没有狐狸的洞口，用o代表有狐狸的洞口。对于<span class="math inline">\(n=5\)</span>的情况，我们从右往左依次检查试试：</p>
<table>
<thead>
<tr class="header">
<th>检查洞口</th>
<th>白天抓捕完后</th>
<th>过了一晚上后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>oooo<strong>x</strong></td>
<td>ooooo</td>
</tr>
<tr class="even">
<td>4</td>
<td>ooo<strong>x</strong>o</td>
<td>oooox</td>
</tr>
<tr class="odd">
<td>3</td>
<td>oo<strong>x</strong>ox</td>
<td>oooxo</td>
</tr>
<tr class="even">
<td>2</td>
<td>o<strong>x</strong>oxo</td>
<td>xoxox</td>
</tr>
</tbody>
</table>
<p>可以看出最后一次抓捕的下一个白天，所有奇数洞都没有狐狸。</p>
<p>下面有一个重要的结论：</p>
<p>每天检查之后，被检查的洞的右边<strong>不会存在开局位于奇数洞</strong>的狐狸。</p>
<p>为什么呢？</p>
<p>因为开局在奇数洞的狐狸，在奇数次抓捕时必定在奇数洞里，在偶数次抓捕时必定在偶数洞里。开局在偶数洞的狐狸正好相反。而从奇数洞走到旁边的奇数洞需要2个晚上，被检查的洞的左边的狐狸若是想走到右边，必定会在移动时遇到抓捕。</p>
<p>这里还应注意到的是，我们第一天检查5号洞口后，4号洞口的狐狸当晚就会分身去5号洞口，也就是说检查两边的洞口是<strong>无效的</strong>。因此3天即可抓捕完奇数洞狐狸。</p>
<p>如果要抓开局位于偶数洞的狐狸呢？</p>
<table>
<thead>
<tr class="header">
<th>检查洞口</th>
<th>白天抓捕完后</th>
<th>过了一晚上后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>ooo<strong>x</strong>o</td>
<td>oooox</td>
</tr>
<tr class="even">
<td>3</td>
<td>oo<strong>x</strong>ox</td>
<td>oooxo</td>
</tr>
<tr class="odd">
<td>2</td>
<td>o<strong>x</strong>oxo</td>
<td>xoxox</td>
</tr>
</tbody>
</table>
<p>3天即可抓捕完。</p>
<p>然后呢，抓奇数洞狐狸？诶奇数洞怎么已经没有狐狸了？这是因为我们花了奇数天抓捕，开局偶数洞的狐狸一晚上后都在奇数洞。那么我们能不能把这个当作开局状态，再来一次偶数洞狐狸抓捕？</p>
<p>当然可以！最后答案是<span class="math inline">\(\{4,3,2,4,3,2\}\)</span>，但是这不是字典序最小的方案。因为选择从左到右给洞穴标号还是从右到左给洞穴标号是不重要的，所以答案为<span class="math inline">\(\{2,3,4,2,3,4\}\)</span>.</p>
<p>再经过一些推导，洞穴个数<span class="math inline">\(n\)</span>为奇数时都为这种情况，即<span class="math inline">\(\{2,3,4,\cdots ,n-1,2,3,4,\cdots ,n-1\}\)</span>.</p>
<p><span class="math inline">\(n\)</span>为偶数时，比如<span class="math inline">\(n=4\)</span>时，因为<span class="math inline">\(n-1=3\)</span>为奇数，我们就先抓开局奇数洞狐狸：</p>
<table>
<thead>
<tr class="header">
<th>检查洞口</th>
<th>白天抓捕完后</th>
<th>过了一晚上后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>oo<strong>x</strong>o</td>
<td>ooox</td>
</tr>
<tr class="even">
<td>2</td>
<td>o<strong>x</strong>ox</td>
<td>xoxo</td>
</tr>
<tr class="odd">
<td>3</td>
<td>xo<strong>x</strong>o（？）</td>
<td>oxox</td>
</tr>
<tr class="even">
<td>2</td>
<td>o<strong>x</strong>ox（？）</td>
<td>xoxo</td>
</tr>
</tbody>
</table>
<p>诶诶诶等一下！这最后两次都抓了个空气啊！</p>
<p>这是因为<span class="math inline">\(n\)</span>为偶数时抓奇数洞狐狸所需天数不是奇数天而是偶数天了。开局偶数洞的狐狸一晚上后都在偶数洞。我们要抓偶数洞狐狸，但是不能检查两边的洞口（也就是第1个洞口不能是<span class="math inline">\(n\)</span>），所以我们调换方向，从2号洞口开始。</p>
<table>
<thead>
<tr class="header">
<th>检查洞口</th>
<th>白天抓捕完后</th>
<th>过了一晚上后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>o<strong>x</strong>oo</td>
<td>xooo</td>
</tr>
<tr class="even">
<td>3</td>
<td>xo<strong>x</strong>o</td>
<td>oxox</td>
</tr>
</tbody>
</table>
<p>成功！最后结果是<span class="math inline">\(\{3,2,2,3\}\)</span>，调换一下编号方向就是<span class="math inline">\(\{2,3,3,2\}\)</span>. 所以<span class="math inline">\(n\)</span>为偶数时答案为<span class="math inline">\(\{2,3,\cdots n-1,n-1,n-2,\cdots ,1\}\)</span>.</p>
<h2 id="cf1584b-coloring-rectangles">CF1584B Coloring Rectangles</h2>
<p>刚看到这题的时候没什么想法，就乱试。试了半天发现似乎<span class="math inline">\(1\times 3\)</span>是最优的切法。然后就开始纠结在特判两条边都不能被<span class="math inline">\(3\)</span>整除的情况上。现在回想起来，自己的思维还是太窄了。</p>
<p>然后就想了个DP做法。对于<span class="math inline">\(1\times n\)</span>的长方形而言，只需要贪心尽可能多地切成<span class="math inline">\(1\times 3\)</span>即可。模拟一下就会发现答案是<span class="math inline">\(\lceil \frac{n}{3} \rceil\)</span>​. 于是就可以用DP做了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXNM; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; MAXNM; j++) &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + ((j + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>), dp[i][j - <span class="number">1</span>] + ((i + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而看数据范围<span class="math inline">\(1 \leq n, m \leq 3 \cdot 10^4\)</span>，被卡了。所以下面是官方题解：</p>
<p>首先找上色后矩形的性质：若一个矩形按照题目要求上色，则相邻的行/列的上色图案正好相反，相邻两行的上色和未上色方块数相同。若长和宽都为偶数，则每两行和列的上色图案将会完全相同。若一个为偶数一个为奇数，则每两行或列的上色图案将会完全相同，这两行内部互相上色方块数将相差1. 这两种情况下上色和未上色方块数都相同，即上色方块占所有方块的<span class="math inline">\(\frac{1}{2}\)</span>。但若长和宽都为奇数，上色和未上色方块数将会相差1. 令方块总数（面积）为<span class="math inline">\(S\)</span>, 则上色方块数为<span class="math inline">\(\frac{S - 1}{2}\)</span>, 占所有方块的<span class="math inline">\(\frac{S - 1}{2 \cdot S}\)</span>.</p>
<p>我们的期望是上色方块的比例尽可能小。根据题目条件<span class="math inline">\(S\geq 2\)</span>，因此当<span class="math inline">\(S=3\)</span>时<span class="math inline">\(\frac{S - 1}{2 \cdot S}=\frac{1}{3}\)</span>为可能的最小值。因此，这就是对答案的最小估计：<span class="math inline">\(n \cdot m \cdot \frac{1}{3} \leq answer\)</span>.</p>
<p>现在，如果我们构造出一个要求必须给<span class="math inline">\(cnt\)</span>个方块上色的剪切方案，且<span class="math inline">\(\frac{n \cdot m}{3} \leq cnt &lt; \frac{n \cdot m}{3} + 1\)</span>，那么答案就是<span class="math inline">\(cnt\)</span>. （也即这个剪切方案就是最优方案）因为<span class="math inline">\(cnt\)</span>是满足我们估计的最小的整数。</p>
<p>如果一条边能被3整除，那么很明显你可以把它全部切成<span class="math inline">\(1\times 3\)</span>的矩形然后得到最优解。</p>
<p>如果这两条边被3除后余1和1，或者余2和2，那么你可以把它切成一些<span class="math inline">\(1\times 3\)</span>的矩形，加上一个<span class="math inline">\(1\times 4\)</span>或<span class="math inline">\(2\times 2\)</span>的矩形。多出来的这个矩形里要给2个方块上色，显然满足要求。</p>
<p>如果这两条边被3除后余1和2，那么你可以把它切成一些<span class="math inline">\(1\times 3\)</span>的矩形，加上一个<span class="math inline">\(1\times 2\)</span>的矩形。多出来的这个矩形里要给1个方块上色，显然满足要求。</p>
<p>由答案必须是整数，可得答案为<span class="math inline">\(\lceil \frac{n \cdot m}{3} \rceil\)</span>.</p>
<h2 id="p5824-十二重计数法">P5824 十二重计数法</h2>
<p>自己做的，好像有些错误。先记着吧。</p>
<ol type="1">
<li>问题可转化成有<span class="math inline">\(n\)</span>个有编号的格子，每个格子可填入<span class="math inline">\(1\sim m\)</span>的任意整数。题目正好对应为<span class="math inline">\(m\)</span>进制下<span class="math inline">\(1\sim n\)</span>位数的个数，也即<span class="math inline">\(n^m\)</span>.（<strong>可重复排列</strong>）</li>
<li>先从<span class="math inline">\([1,n]\)</span>中选出<span class="math inline">\(m\)</span>个数，然后全排列。即<span class="math inline">\(C_n^m\cdot A_m^m\)</span>.</li>
<li>可拆分成：先从<span class="math inline">\([1,n]\)</span>中选出<span class="math inline">\(m\)</span>个数，使它们装到<span class="math inline">\(m\)</span>个盒子中，每个盒子至多装一个球，也即问题2；剩下的<span class="math inline">\(n-m\)</span>个球可以任意装到盒子中，也即问题1. 答案<span class="math inline">\(C_n^m\cdot A_m^m\cdot (n-m)^m\)</span>.</li>
<li>盒子全部相同，意味着哪些球在一个盒子里重要，但是具体在哪一个盒子不重要。问题1除以盒子的排列数<span class="math inline">\(A_m^m\)</span>即可。但是我们也可以用隔板法：<span class="math inline">\(1,2,\cdots ,n\)</span>编号的小球打乱顺序后之间放上<span class="math inline">\(m-1\)</span>个隔板。即为<span class="math inline">\(A_n^n\cdot C_{n+1}^{m-1}\)</span>.</li>
<li><strong>不可重复组合</strong>：<span class="math inline">\(C_n^m\)</span>.</li>
<li>先从<span class="math inline">\([1,n]\)</span>中选出<span class="math inline">\(m\)</span>个数直接装到盒子中，剩下的<span class="math inline">\(n-m\)</span>个球任意装。<span class="math inline">\(C_n^m\cdot A_{n-m}^{n-m}\cdot C_{n-m+1}^{m-1}\)</span>.</li>
<li>球全部相同，意味着盒子里有多少球重要，但是具体是哪些球不重要。可用隔板法：<span class="math inline">\(n\)</span>个小球中间放上<span class="math inline">\(m-1\)</span>个隔板，即<span class="math inline">\(C_{n+1}^{m-1}\)</span>.</li>
<li>盒子只有两种状态：装了一个球/没装球。选出装了球的盒子即为<span class="math inline">\(C_m^n\)</span>.</li>
<li>每个盒子都装一个球后剩下的球有<span class="math inline">\(n-m\)</span>个，回到问题7，即<span class="math inline">\(C_{n-m+1}^{m-1}\)</span>.</li>
<li>从这开始就有点难了，先模拟一下：设装球最少的盒子装了<span class="math inline">\(x\)</span>个球，那么装球第二少的盒子可以装<span class="math inline">\([x,m]\)</span>个，</li>
</ol>
<h2 id="广东工业大学新生赛初赛题解与反思">2021广东工业大学新生赛初赛题解与反思</h2>
<p>初赛结果不理想，只出了5个题。</p>
<p>其实回想起来有些题赛时本来能做出来的，但是因为各种原因没做好，在此纪录。也一并为以后的学习指明方向。</p>
<h3 id="a-简单的求零点问题"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/A">A 简单的求零点问题</a></h3>
<p>很显然，用二分找零点。但是我一看到这题就有点犯难，为什么呢？因为我<strong>连二分都不能熟练地码出来</strong>。</p>
<p>所以今天整理一下二分。（参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008699980">这篇文章</a>）</p>
<h4 id="如何快速判断自己的二分程序是否正确">如何快速判断自己的二分程序是否正确</h4>
<p>我们知道二分的思想就是每次取一半，想象一下，不管给我们的数组有多长，每次取一半，最终都会被压缩成长度为 1 的数组，然后在这个长度为 1 的数组里判断并返回，所以我们可以直接用长度为 1 的数组来测试程序。</p>
<h4 id="二分查找">二分查找</h4>
<p>给定长度为n的数组（<span class="math inline">\(n\geq 1\)</span>）</p>
<p>问题1：找到值为value的元素的下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 注意防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt; value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] &lt; value) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：找到<strong>第一个</strong>值为value的元素的下标</p>
<p>这时候遇到相等也不能直接返回，只能排除掉右侧的所有数。</p>
<p>数组的长度为 1 或 2 时，<code>middle</code>为 0. 若<code>array[0]</code>为要找的数，则<code>right</code>将被赋值为 -1，循环结束，<code>left</code>为答案。数组长度为 2 且<code>array[1]</code>为要找的数时，<code>left</code>将被赋值为 1，回到数组长度为 1 的情况。</p>
<p>因此最后再判断一下<code>left</code>是否为要找的数，如果是则返回，否则答案不存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt;= value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题3：找到<strong>最后一个</strong>值为value的元素的下标</p>
<p>这就是问题2的倒序版本。改动两个地方即可</p>
<ol type="1">
<li><p><code>if (array[middle] &gt;= value)</code> 中的等号去掉；</p></li>
<li><p><code>if (right &gt;= 0 &amp;&amp; array[right] == value) &#123;return right;&#125;</code></p></li>
</ol>
<p>问题4：找到<strong>第一个大于等于</strong>value的下标</p>
<p>在问题2中，我们的策略是让<code>left</code>刚好为第一个大于等于value的数的下标，而让<code>right</code>刚好为第一个小于value的数的下标。因此只需要去掉最后判断答案存在的<code>array[left] == value</code>条件即可。</p>
<p>问题5：找到<strong>最后一个小于等于</strong>value的下标</p>
<p>与问题4同理，去掉问题3中最后判断答案存在的<code>array[right] == value</code>条件。</p>
<h3 id="b-abeasy"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/B">B a+b(easy)</a></h3>
<p>这题能卡我，题面也要背点锅。赛时的样例1输入为<code>1 2</code>输出为<code>3</code>. 而我又<strong>对位运算不够熟悉</strong>，在无论如何也找不到对应的x和y时陷入了自我怀疑之中。</p>
<p>题目本身确实很简单。取或运算可以看成不进位，只把每一位单独加起来。取和运算就看成每一位会不会进位（二进制加法只有进位/不进位两种可能）。那么加起来自然就与这两个数本身加起来相等。</p>
<h3 id="c-百家姓与年龄"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/C">C 百家姓与年龄</a></h3>
<p>这道题题面看起来有点混乱……本来不复杂的描述参杂了3个人进来，还有两个人名字就差一个字母。当时愣是来回看了三四遍才明白意思。<strong>下次读题要冷静，快速排除无关信息。</strong></p>
<p>读完题，把式子列出来一算就很显然了。令<span class="math inline">\(x\)</span>为出生年份，<span class="math inline">\(y\)</span>为排位。 <span class="math display">\[
\begin{aligned}
a&amp;=50(2y+5)+1771-x\\
&amp;=100y+2021-x
\end{aligned}
\]</span> 联想到今年是2021年，<span class="math inline">\(2021-x\)</span>为年龄，且年龄小于100岁。年龄即为<span class="math inline">\(a\)</span>的最后两位数，排位为余下的数。</p>
<p><del>所以这道题的保质期已经不足两个月了。</del></p>
<p><del>所以居然是年龄小于100而不是百家姓排位小于100。</del></p>
<h3 id="d-帮助小鱼"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/D">D 帮助小鱼</a></h3>
<blockquote>
<p>接下来 <span class="math inline">\(n\)</span> 个数，第 <span class="math inline">\(i\)</span> 个数代表第 <span class="math inline">\(i\)</span> 个部长摸了那一条鱼。</p>
</blockquote>
<p>又懵逼半天，这到底输入的啥。</p>
<p>最后就是开个桶或者map记录鱼被谁摸，然后顺序输出就好了。</p>
<h3 id="e-上楼方式"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/E">E 上楼方式</a></h3>
<p>整个比赛中做的最错误的决定就是第二个读这道题。</p>
<p>当时自己晚了3分钟开始（定了个开始前20分钟的闹钟，响了以后就坐在电脑前等，然后居然忘记定开场时的闹钟了），然后眼看着其他题都被人AC过了，这道题还没有。再加上有上楼梯这种经典递推板题的存在，我信 心 满 满地准备试一试。</p>
<p><del>这题怎么也有3个莫名其妙的名字。</del></p>
<p>然后就读错题了，3步登上教堂我想当然地以为是踩3阶楼梯。其实是指在楼梯上移动三次，比如1-2-3-4.</p>
<p>第一阶必定是1，最后一阶必定是<span class="math inline">\(n\)</span>，所以上楼方案数为 <span class="math display">\[
C_{n-2}^2=\dfrac{n\times (n-1)}{2}
\]</span> 但是还有一个细节：不能直接对被除数取模。一个 workaround 是判断当前<span class="math inline">\(n\)</span>的奇偶性然后先除后乘，避免溢出。</p>
<h3 id="f-气球"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/F">F 气球</a></h3>
<p>先看两种买法折算的单价：</p>
<ul>
<li><code>3 * a &lt; 2 * b</code>：两件买法更优。这时最多可能买1个三件，因为买2个三件时显然不如买3个两件。</li>
<li><code>3 * a &gt; 2 * b</code>：三件买法更优。这时可能买1或2个两件，买3个两件时就必定不如买2个三件。</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> * a &lt; <span class="number">2</span> * b) &#123;</span><br><span class="line">    <span class="comment">// choose 2</span></span><br><span class="line">    ans = a * ((n + <span class="number">2</span> - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, a * ((n - <span class="number">3</span> + <span class="number">2</span> - <span class="number">1</span>) / <span class="number">2</span>) + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// choose 3;</span></span><br><span class="line">    ans = b * ((n + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, b * ((n - <span class="number">2</span> + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>) + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, b * ((n - <span class="number">4</span> + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>) + <span class="number">2</span> * a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="g-zrgg出题"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/G">G zrgg出题</a></h3>
<p>前<span class="math inline">\(x\)</span>个数中<span class="math inline">\(a_i\)</span>的倍数的个数为：<span class="math inline">\(\left\lfloor\dfrac{x}{a_i}\right\rfloor\)</span>，容斥一下就可得到<span class="math inline">\([l,r]\)</span>之间的倍数个数为<span class="math inline">\(\left\lfloor\dfrac{r}{a_i}\right\rfloor-\left\lfloor\dfrac{l-1}{a_i}\right\rfloor\)</span>.</p>
<p>但是需要注意，三个<span class="math inline">\(a_i\)</span>之间有公倍数，这些公倍数被重复计算了，所以我们需要减回去。但是减回去的时候同时为三个数的公倍数又被多减了，所以需要再加回去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, l, r, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiple_count</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r / a) - ((l - <span class="number">1</span>) / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        ans += <span class="built_in">multiple_count</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">            ans -= <span class="built_in">multiple_count</span>(<span class="built_in">lcm</span>(a[i], a[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">        ans += <span class="built_in">multiple_count</span>(<span class="built_in">lcm</span>(a[<span class="number">0</span>], <span class="built_in">lcm</span>(a[<span class="number">1</span>], a[<span class="number">2</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="h-abhard"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/H">H a+b(hard)</a></h3>
<p>基于B题的铺垫，可以直接想到把<span class="math inline">\(b_i\)</span>和<span class="math inline">\(c_i\)</span>加起来得到 <span class="math display">\[
d_i=
\begin{cases}
a_i+a_{i+1}&amp;1\leq i&lt;n\\
a_i+a_1&amp;i=n
\end{cases}
\]</span> 当<span class="math inline">\(2\leq i&lt; n\)</span>时，<span class="math inline">\(d_i-d_{i-1}=a_{i+1}-a_{i-1}\)</span>. 由<span class="math inline">\(n\)</span>为奇数，得 <span class="math display">\[
d_{n-1}-d_{n-2}+d_{n-3}-d_{n-4}+\cdots +d_{2}-d_{1}=a_n-a_1
\]</span> 并且<span class="math inline">\(d_n=a_n+a_1\)</span>，所以可以直接求出<span class="math inline">\(a_1\)</span>. 之后就很简单了。</p>
<h3 id="i-定向越野是世界上最好的运动"><a target="_blank" rel="noopener" href="https://gdutcode.cn/contest/15/problem/I">I 定向越野是世界上最好的运动</a></h3>
<p>这题看起来就很吓人，有点让人无所适从。但是我们注意数据范围：<span class="math inline">\(2\leq n\leq 12\)</span>，时间限制3秒。这数据范围一看就是妥妥的<strong>NP问题</strong>，不是多项式时间能解决的。所以我们可以直接从比较暴力的思路想。</p>
<p>先看一个简化的问题：如果两人速度相同，那么问题可以转化成：经过所有点位（包括起点终点）且不重复走某个点位的最优方案。这样走出来的路径将是一个环，而我们从起点和终点分割这个环得到的就是两人的行走路线。这就是著名的“旅行商问题（Travelling salesman problem)”。我们可以使用状态压缩动态规划来求解。</p>
<p>啥是状态压缩呢？很简单，本来我们有<span class="math inline">\(n\)</span>个点位，那么对于每个点位是否经过就一共有一个<span class="math inline">\(n\)</span>维的状态，每个维度只能取经过/没经过两个值。那么现在我们可以用一个二进制数来对应一种状态，用0和1表示没经过和经过。这样就把<span class="math inline">\(n\)</span>维的状态<strong>压缩</strong>成了一维。</p>
<p>定义<span class="math inline">\(dp(S,i)\)</span>表示当前在点位<span class="math inline">\(i\)</span>，已访问点位集合为<span class="math inline">\(S\)</span>​（用二进制表示）的最短路程，那么状态转移方程为 <span class="math display">\[
dp(S,i)=\min\left\{d(S-\{i\},j)+dist(j,i)\mid j\in S\right\}
\]</span> 对于这道问题，我们只需要一点点适配：设没经过终点（最后一个点位）之前是第一个人A在走，经过终点回到起点时是第二个人B在走。那么修改求两点距离的函数<span class="math inline">\(dist(j,i)\)</span>为此人走过这段距离所需时间即可。</p>
<h2 id="cf1603a-di-visible-confusion">CF1603A Di-visible Confusion</h2>
<p>首先分析操作：决定一个数能否被删除的只有它的序号，因此删除某个数对它左边的数没有影响，而右边的数也不会关心具体是哪个数被删除了。所以，从右往左贪心删除一定是最优的方案。</p>
<p>题目问的是一个序列能不能被全部删除，所以我们就要找反面：从右往左贪心删除时会遇到所有数都无法被删除的局面。再联系刚才说了删除操作对左边的数没影响可知，如果一个序列前面某几项都被<span class="math inline">\((i+1)\)</span>整除，那么这个序列必定无法被全部删除。即若第一项被<span class="math inline">\(2\)</span>整除，整个序列必定无法被全部删除。</p>
<p>继续推广，如果第<span class="math inline">\(i\)</span>项被<span class="math inline">\((i+1)!\)</span>整除，那么整个序列必定无法被全部删除。由于阶乘的增长速度是很大的，而<span class="math inline">\(a_i\leq 10^9\)</span>，所以一旦阶乘超过<span class="math inline">\(10^9\)</span>就不用看后面的了。</p>
<p>写出来一交，Wrong Answer.</p>
<p>上面推广的过程是错误的。应该把<span class="math inline">\((i+1)!\)</span>换成<span class="math inline">\(LCM(2,3,\cdots,i+1)\)</span>. 把最小公倍数当成乘法这个操作在新生赛初赛中已经搞过一次，现在印象够深刻了。说到底，还是数论相关题目自己做得太少，知识也不牢固。</p>
<h3 id="最大公因数greatest-common-divisor">最大公因数（Greatest Common Divisor）</h3>
<p>最大公因数的算法是辗转相除法，基于一个原理：如果<span class="math inline">\(a&gt;b\)</span>则<span class="math inline">\(gcd(a,b)=gcd(b,a-b)\)</span>. 我们可以验证一下正确性 <span class="math display">\[
\begin{aligned}
a&amp;=2^2\times 3^2\times 7=252\\
b&amp;=2\times 3^3\times 5=270\\
b-a&amp;=2\times 3^3\times 5-2^2\times 3^2\times 7\\
&amp;=2\times 3^2\times (3\times 5-2\times 7)\\
&amp;=2\times 3^2\times 1
\end{aligned}
\]</span> 两个互质的数相减，得到的数也和小的那个数互质（<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/2456631/if-two-numbers-are-relatively-prime-is-their-sum-relatively-prime-to-one-of-the">证明</a>）。<span class="math inline">\(gcd(a,b)=gcd(b,a-b)=1\)</span>.</p>
<p>如果<span class="math inline">\(a-b&gt;b\)</span>，那么就继续相减到<span class="math inline">\(a-b&lt;b\)</span>为止，所以直接<span class="math inline">\(gcd(a,b)=gcd(b,a\bmod b)\)</span>.</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小公倍数least-common-multiple">最小公倍数（Least Common Multiple）</h3>
<p>考虑两个数<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，将这两个数分解质因数 <span class="math display">\[
\begin{aligned}
a&amp;=2^2\times 3^2\times 7=252\\
b&amp;=2\times 3^3\times 5=270
\end{aligned}
\]</span> 这两个数的最大公因数（Greatest Common Divisor）就是它们质因数的<strong>交集</strong>的乘积 <span class="math display">\[
gcd(252,270)=2\times 3^2
\]</span> 考虑最小公倍数的性质。最小公倍数必须被<span class="math inline">\(a\)</span>或<span class="math inline">\(b\)</span>​整除，也就是说最小公倍数必须同时包含这两数的所有质因数，所以是它们质因数的<strong>并集</strong>的乘积。怎样得到这个乘积？<span class="math inline">\(a\times b\)</span>，然后容斥除掉共同的质因数<span class="math inline">\(gcd(a,b)\)</span>就好了。 <span class="math display">\[
\begin{aligned}
lcm(252,270)&amp;=\dfrac{252\times 270}{gcd(252,270)}\\
&amp;=\dfrac{2^2\times 3^2\times 7\times 2\times 3^3\times 5}{2\times 3^2}\\
&amp;=3780
\end{aligned}
\]</span> 实际编程中一般先除后乘，防止溢出。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cf1601a-array-elimination">CF1601A Array Elimination</h2>
<p>拿到题目简单分析一下：按位取AND，任意下标选择。所以其实数组的排列以及二进制下每一位整体的排列都不重要。由于取AND的性质，每次消去操作对于某一位来说要么消去<span class="math inline">\(k\)</span>个1要么无影响。所以，实际上每一位内部0和1是怎样排布的也无任何影响。</p>
<p>那问题就很简单了，某个<span class="math inline">\(k\)</span>能够单独消掉每一位的所有1，就等价于能消掉所有位。设第<span class="math inline">\(i\)</span>位有<span class="math inline">\(n_i\)</span>个1，则对任意<span class="math inline">\(i\)</span>需满足<span class="math inline">\(k\mid n_i\)</span>. 也就是说<span class="math inline">\(k\bmod gcd(\{n\})=0\)</span>.</p>
<h2 id="cf1515a-phoenix-and-gold">CF1515A Phoenix and Gold</h2>
<p>从反面分析，假如现在有长为<span class="math inline">\(k\)</span>的重量子序列使得<span class="math inline">\(\sum\limits_{j = 1}^{k}w_j = x\)</span>，那么要避免这种情况只需要从余下的重量中找出一个不等于<span class="math inline">\(w_k\)</span>的重量替换即可。由于该子序列可以任意重新排列，所以只要子序列中任意两项不相等就一定可以找到符合要求的排列。综上，无法避免的情况为整个序列全部相等，且存在<span class="math inline">\(i\)</span>使得<span class="math inline">\(\sum\limits_{j = 1}^{i}w_j = x\)</span>；或者此时已经没有可用于替换的重量了，也即<span class="math inline">\(\sum\limits_{j = 1}^{n}w_j = x\)</span>.</p>
<p>具体怎么实现呢？我又卡了。因为我没注意到这句话：</p>
<blockquote>
<p>It is guaranteed that the weights are <strong>pairwise distinct</strong>.</p>
</blockquote>
<p>所以其实只要看后一种情况是否出现就好了，否则都是可以的。我们从前往后加，如果遇到放不了的就先放它的下一个就好了。</p>
<p>我说为啥800难度的会这么复杂。</p>
<h2 id="cf1515c-phoenix-and-towers">CF1515C Phoenix and Towers</h2>
<p>不允许任意两个塔楼高度差严格大于<span class="math inline">\(x\)</span>，相当于不允许最高的塔楼和最低的塔楼的高度差严格大于<span class="math inline">\(x\)</span>. 联系<span class="math inline">\(1 \le h_i \le x\)</span>的条件，如果高度差大于<span class="math inline">\(x\)</span>，超出的部分必定不止一个块。那么此时显然可以把多出来的那些块补到最低的塔楼上面。因此，不存在无法达到要求的情况。</p>
<p>然后就不知道怎么写了。</p>
<p>官方题解：上述那种情况是因为有一次或以上未把块加到当前最矮的塔楼上，因此只需一直贪心把块加到当前最矮的塔楼即可。</p>
<h2 id="cf1606c-banknotes">CF1606C Banknotes</h2>
<p>某面值的钞票数量不能比较它更大一级的一张钞票能表示的还多 <span class="math display">\[
10^{a_{i+1}}&gt;x_i\cdot 10^{a_i}
\]</span> 所以 <span class="math display">\[
x_i\leq \frac{10^{a_{i + 1}}}{10^{a_i}} - 1
\]</span> 所以我们只需要贪心给到<span class="math inline">\(x_i=\min(\mathit{left}, \frac{10^{a_{i + 1}}}{10^{a_i}} - 1)\)</span>，其中<span class="math inline">\(left\)</span>是剩余可以分配的钞票数目。</p>
<h2 id="cf1610c-keshi-is-throwing-a-party">CF1610C Keshi Is Throwing a Party</h2>
<p>考虑从穷到富决策是否邀请第<span class="math inline">\(i\)</span>个人，我们需要知道邀请后是否满足要求。我们从穷到富枚举所以前面有多少比他穷的人已经确定了，但是我们并不知道后面还会邀请多少比他富的人。所以这里还缺个信息：我们一共要邀请多少个人？这就又增加一个变量，整体时间复杂度达到<span class="math inline">\(O(n^2)\)</span>，我们需要用二分优化。</p>
<p>为什么呢？题目要求的是输出<strong>最大的</strong>能邀请的人数，而如果能邀请人数<span class="math inline">\(n\)</span>，那么也一定能邀请比<span class="math inline">\(n\)</span>小的人数。所以人数是从0开始连续增大的（<strong>单调性</strong>），某人数下无法邀请那么比该人数还大时也无法邀请（<strong>局部舍弃性</strong>）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/09/07/xor-value-of-the-first-n-natural-numbers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/07/xor-value-of-the-first-n-natural-numbers/" class="post-title-link" itemprop="url">求前 n 个自然数的异或值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-07 21:01:00" itemprop="dateCreated datePublished" datetime="2021-09-07T21:01:00+08:00">2021-09-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>时间复杂度 <span class="math inline">\(O(1)\)</span> ，分为感性认识和理性认识。</p>
<p>如无特别注明，下文所指均为二进制下的数位。按位逻辑运算符号表在<a target="_blank" rel="noopener" href="https://imzlp.com/posts/23224/#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">此处</a>。</p>
<h2 id="感性认识">感性认识</h2>
<p>由于 <span class="math inline">\(0\oplus 1=1\)</span>，问题也可以转化成求 <span class="math inline">\([1, n]\)</span> 的异或值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Number Binary-Repr  XOR-from-1-to-n</span><br><span class="line">1         1           [0001] 1</span><br><span class="line">2        10           [0011] 3</span><br><span class="line">3        11           [0000] 0  &lt;----- We get a 0</span><br><span class="line">4       100           [0100] 4  &lt;----- Equals to n</span><br><span class="line">5       101           [0001] 1</span><br><span class="line">6       110           [0111] 7</span><br><span class="line">7       111           [0000] 0  &lt;----- We get 0</span><br><span class="line">8      1000           [1000] 8  &lt;----- Equals to n</span><br><span class="line">9      1001           [0001] 1</span><br><span class="line">10     1010           [1011] 11</span><br><span class="line">11     1011           [0000] 0  &lt;------ We get 0</span><br><span class="line">12     1100           [1100] 12 &lt;------ Equals to n</span><br></pre></td></tr></table></figure>
<p>所以我们可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to find XOR of numbers</span></span><br><span class="line"><span class="comment">// from 1 to n.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Method to calculate xor</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeXOR</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// If n is a multiple of 4</span></span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If n%4 gives remainder 1</span></span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If n%4 gives remainder 2</span></span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If n%4 gives remainder 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver method</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">computeXOR</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// This code is contributed by rutvik_56.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="理性认识">理性认识</h2>
<p>记 <span class="math inline">\(f(x,\ y)\)</span> 为 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的所有整数的异或值。</p>
<p>现在考虑 <span class="math inline">\(f(2^k,\ 2^{k+1}-1)\)</span>. 令 <span class="math inline">\(k\geq 1\)</span>，则 <span class="math inline">\(2^k\)</span> 为偶数。且这里面的 <span class="math inline">\(2^k\)</span> 个数从左往右第 <span class="math inline">\(k+1\)</span> 位（最高位）都为 <span class="math inline">\(1\)</span>. 再结合异或运算法则我们就知道，将这 <span class="math inline">\(2^k\)</span> 个数的最高位去掉，异或值不变。也就是说， <span class="math display">\[
f(2^k,\ 2^{k+1} -1) = f(2^k - 2^k,\ 2^{k+1} -1 -2^k) = f(0,\ 2^k -1).
\]</span> 所以， <span class="math display">\[
\begin{aligned}
f(0,\ 2^{k+1} -1)&amp;=f(0,\ 2^k -1)\oplus f(2^k,\ 2^{k+1} -1)\\
&amp;=f(0,\ 2^k -1)\oplus f(0,\ 2^k -1)\\
&amp;=0.
\end{aligned}
\]</span> 也就是， <span class="math display">\[
f(0,\ 2^k - 1) = 0\ (k &gt;= 2).
\]</span></p>
<p>对于 <span class="math inline">\(f(0,\ n)\ (n\geq 4)\)</span> ，设 <span class="math inline">\(n\)</span> 的最高位在第 <span class="math inline">\(k\)</span> 位 <span class="math inline">\((k \geq 2)\)</span>. 则 <span class="math display">\[
f(0,\ n) = f(0,\ 2^k - 1)\oplus f(2^k,\ n) = f(2^k,\ n).
\]</span> <span class="math inline">\([2^k,\ n]\)</span> 共有 <span class="math inline">\(n+1-2^k\)</span> 个数，设为 <span class="math inline">\(m\)</span>. 这些数的第 <span class="math inline">\(k\)</span> 位（最高位）共有 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(1\)</span>.</p>
<p><strong>(a)</strong> 当 <span class="math inline">\(n\)</span> 为奇数时，<span class="math inline">\(m\)</span> 为偶数，则最高位有偶数个 <span class="math inline">\(1\)</span> ，所以 <span class="math display">\[
f(0,\ n) = f(2^k,\ n) = f(0,\ n - 2^k).
\]</span> 且 <span class="math inline">\(n-2^k\)</span> 与 <span class="math inline">\(n\)</span> 同奇偶，我们可以递推： <span class="math display">\[
f(0,\ n) = f(0,\ n - 2^k) = f(0,\ n - 2^k - 2^{k-1}) = \cdots = f(0,\ n \bmod 4).
\]</span> 注：<span class="math inline">\(n\geq4\)</span>. 每一步递推都将最高位去掉。</p>
<p>当 <span class="math inline">\(n \bmod 4= 1\)</span> 时， <span class="math inline">\(f(0,\ n) = f(0,\ 1) = 1\)</span>.</p>
<p>当 <span class="math inline">\(n \bmod 4 = 3\)</span> 时， <span class="math inline">\(f(0,\ n) = f(0,\ 3) = 0\)</span>.</p>
<p><strong>(b)</strong> 当 <span class="math inline">\(n\)</span> 为偶数时，<span class="math inline">\(m\)</span> 为奇数，则最高位有奇数个 <span class="math inline">\(1\)</span> ，所以 <span class="math display">\[
f(0,\ n) = f(2^k,\ n) = f(0,\ n - 2^k) \vee 2^k.
\]</span> 注：最高位的 <span class="math inline">\(1\)</span> 我们先提出来，最后用取或（<span class="math inline">\(\vee\)</span>）加回去。</p>
<p>像<strong>(a)</strong>那样递推时，我们会发现每一步都保留了当前最高位，所以除了 <span class="math inline">\(n\)</span> 的最后两位其余都会被保留下来，我们记这个数为 <span class="math inline">\(n&#39;\)</span>. <span class="math display">\[
f(0,\ n) = f(2^k,\ n) = f(0,\ n \bmod 4) \vee n&#39;.
\]</span></p>
<p>当 <span class="math inline">\(n \bmod 4=0\)</span> 时 <span class="math inline">\(n\)</span> 的后两位是 <span class="math inline">\(00\)</span>，所以 <span class="math inline">\(n=n&#39;\)</span>. <span class="math display">\[
f(0,\ n) = f(0,\ n \bmod 4) \vee n&#39; = f(0,\ 0) \vee n = n.
\]</span> 当 <span class="math inline">\(n \bmod 4 = 2\)</span> 时 <span class="math inline">\(n=n&#39;+2\)</span>，所以 <span class="math display">\[
\begin{aligned}
f(0,\ n) &amp;= f(0,\ n \bmod 4) \vee n&#39;\\
&amp;=f(0,\ 2) \vee n&#39;\\
&amp;=3 \vee n&#39;\\
&amp;=3 \vee 2 \vee n\\
&amp;=n+1.
\end{aligned}
\]</span> 综上所述， <span class="math display">\[
f\left( 0,\ n\right) =\left\{
\begin{array}{l}
n&amp;, n \bmod 4=0\\
1&amp;, n \bmod 4=1\\
n+1&amp;, n \bmod 4=2\\
0&amp;, n \bmod 4=3.
\end{array}
\right.
\]</span> Q.E.D.</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/flyinghearts/archive/2011/03/22/1992001.html">求1到n这n个整数间的异或值 （O(1)算法)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/calculate-xor-1-n/">Calculate XOR from 1 to n - GeeksforGeeks</a> （异或值表格及代码）</li>
<li><a target="_blank" rel="noopener" href="https://siukwan.sinaapp.com/?p=883">问题：求1到n这n个整数间的异或值，即 1 xor 2 xor 3 … xor n</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://richard-zheng.github.io/2021/09/01/dp-being-both-independent-and-overlapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/dp-being-both-independent-and-overlapping/" class="post-title-link" itemprop="url">如何看待「动态规划问题既独立又重叠」</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-01 21:23:00" itemprop="dateCreated datePublished" datetime="2021-09-01T21:23:00+08:00">2021-09-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章的起因是《算法导论》中的一段话：</p>
<blockquote>
<p>"It may seem strange that dynamic programming relies on subproblems being both independent and overlapping. Although these requirements may sound contradictory, they describe two different notions, rather than two points on the same axis. Two subproblems of the same problem are independent if they do not share resources. Two subproblems are overlapping if they are really the same subproblem that occurs as a subproblem of different problems" (CLRS 3rd edition, 386).</p>
</blockquote>
<p>这里的independent和overlap都是啥意思呢？下面是我查了StackOverflow以后得到的结果：</p>
<p>「独立」的意思是说：如果我们说一个解是最优的，那么这个最优的性质并不依赖任何我们要解决的母问题。也就是说不管我们是为了哪个更大的问题来解这个子问题，都会得到这个解。举个简单的例子：从A到B的最短路径经过C，那么我直接求从A到C的最短路径，后者答案应该是前者答案的一部分。这就是最优子结构(optimal substructure)的定义。</p>
<p>「重叠」的意思就很自然：不同的子问题会解多个子子问题，而其中很多子子问题是重复的。有意思的是由于我们刚才的「独立」性质，这些重复的子子问题就算有不同的母问题，他们的解也应该是相同的。因此我们就可以开个数组把这些解存下来。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard Zheng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>

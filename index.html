<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"stay-curious.win","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="人生天地间，忽如远行客。">
<meta property="og:type" content="website">
<meta property="og:title" content="湖面">
<meta property="og:url" content="https://stay-curious.win/index.html">
<meta property="og:site_name" content="湖面">
<meta property="og:description" content="人生天地间，忽如远行客。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Richard Zheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://stay-curious.win/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>湖面</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">湖面</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Richard Zheng</p>
  <div class="site-description" itemprop="description">人生天地间，忽如远行客。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2022/03/26/bezout-theorem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/26/bezout-theorem/" class="post-title-link" itemprop="url">Bezout 定理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-26 15:00:00" itemprop="dateCreated datePublished" datetime="2022-03-26T15:00:00+08:00">2022-03-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>简单起见，我们把两个整数 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span> 的最大公因数记为 <span class="math inline">\((a,b)\)</span>.</p>
<h2 id="euclidean-algorithm">Euclidean algorithm</h2>
<p><strong>Theorem 1</strong> 若存在整数 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(a=r+bk\)</span>，则 <span class="math inline">\((a,b)=(b,r)\)</span>.</p>
<p><em>Proof.</em> 由 <span class="math inline">\(r=a-bk\)</span> 得：<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的公因数都是 <span class="math inline">\(r\)</span> 的因数，也就是 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(r\)</span> 的公因数。所以 <span class="math inline">\((a,b) \leq (b,r)\)</span>. 由 <span class="math inline">\(a=r+bk\)</span> 同理可得 <span class="math inline">\((b,r) \leq (a,b)\)</span>. 因此，<span class="math inline">\((a,b)=(b,r)\)</span>. 证毕。</p>
<p>据此我们可以构造一个数列 <span class="math inline">\(r\)</span>，令 <span class="math inline">\(r_{1}=a, r_{2}=b\)</span>，并且</p>
<p><span class="math display">\[
r_{i}=r_{i-2} \bmod r_{i-1},\;\;\; 0\leq r_{i} &lt; |r_{i-1}|.
\]</span></p>
<p>不失一般性，我们假设 <span class="math inline">\(a \geq b \geq 0\)</span>，那么 <span class="math inline">\(r\)</span> 是单调递减的。所以数列最后一定会出现 <span class="math inline">\(0\)</span>，但是 <span class="math inline">\(0\)</span> 不能作为除数，所以我们规定数列在 <span class="math inline">\(0\)</span> 截止，且 <span class="math inline">\(r_{n+1}=0\)</span>（也即 <span class="math inline">\(0\)</span> 的前一个数是数列末尾）。</p>
<p>现在要证明</p>
<p><span class="math display">\[
(r_{1}, r_{2})=(r_{2}, r_{3})=\cdots=(r_{n},r_{n+1})=r_{n}.
\]</span></p>
<p>由数列的定义得</p>
<p><span class="math display">\[
r_{i-2}=r_{i}+r_{i-1}q_{i-1}.
\]</span></p>
<p>其中 <span class="math inline">\(q_{i-1}\)</span> 为带余除法 <span class="math inline">\(r_{i-2}/r_{i-1}\)</span> 得到的商。应用上面提到的定理得 <span class="math inline">\((r_{i-1}, r_{i})=(r_{i-2}, r_{i-1})\)</span>. 若 <span class="math inline">\(i=n+1\)</span>，则我们可以一路递推至 <span class="math inline">\(i=2\)</span> 的情况，也即 <span class="math inline">\((a,b)\)</span>. 由于 <span class="math inline">\(r_{n+1}=0\)</span>，任何数都是零的因数，所以 <span class="math inline">\((r_{n},r_{n+1})=r_{n}\)</span>. 证毕。</p>
<p>这也为我们提供了一种计算最大公因数的高效算法。</p>
<h2 id="bézouts-identity">Bézout's Identity</h2>
<p><strong>Theorem 2</strong> 对于任意非零整数 <span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>，存在整数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 使得</p>
<p><span class="math display">\[
(a,b)=ax+by.
\]</span></p>
<p>特别地，当 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 互质时，存在整数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(ax+by=1\)</span></p>
<p><em>Proof.</em> 使用数学归纳法证明。</p>
<p>下面证明</p>
<p><span class="math display">\[
\forall i \leq n,\,\exists x,y \in \mathbb{Z},\,(r_{i}, r_{i+1})=r_{i}x+r_{i+1}y.
\]</span></p>
<p>初始条件：由 <span class="math inline">\(r_{n+1}=0\)</span> 有</p>
<p><span class="math display">\[
(r_{n}, r_{n+1})=r_{n} \cdot 1 + r_{n+1} \cdot 0.
\]</span></p>
<p>即 <span class="math inline">\(x=1,\ y=0\)</span>（<span class="math inline">\(y\)</span> 是不是只能为 <span class="math inline">\(0\)</span>？）</p>
<p>递推：假设已存在 <span class="math inline">\(x,y \in \mathbb{Z}\)</span> 使得 <span class="math inline">\((r_{i}, r_{i+1})=r_{i}x+r_{i+1}y\)</span>，现在来证存在 <span class="math inline">\(x&#39;,y&#39; \in \mathbb{Z}\)</span> 使得 <span class="math inline">\((r_{i-1}, r_{i})=r_{i-1}x&#39;+r_{i}y&#39;\)</span>.</p>
<p>由数列的定义得</p>
<p><span class="math display">\[
r_{i-1}=r_{i+1}+r_{i}q_{i}.
\]</span></p>
<p>也即</p>
<p><span class="math display">\[
r_{i+1}=r_{i-1}-r_{i}q_{i}.
\]</span></p>
<p>代入递推假设得</p>
<p><span class="math display">\[
\begin{align*}
(r_{i}, r_{i+1})&amp;=r_{i}x+r_{i+1}y\\
&amp;=r_{i}x+(r_{i-1}-r_{i}q_{i})y\\
&amp;=r_{i-1}y+r_{i}(x-q_{i}y).
\end{align*}
\]</span></p>
<p>又由定理 1 得 <span class="math inline">\((r_{i}, r_{i+1})=(r_{i-1}, r_{i})\)</span>（上面已经证明），所以</p>
<p><span class="math display">\[
(r_{i-1}, r_{i})=r_{i-1}y+r_{i}(x-q_{i}y).
\]</span></p>
<p>且 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(x-q_{i}y\)</span> 都为整数，所以 <span class="math inline">\(x&#39;=y, y&#39;=x-q_{i}y\)</span>. 递推证明完成。</p>
<p>结论：当 <span class="math inline">\(i=1\)</span> 时我们得到存在整数 <span class="math inline">\(x,y\)</span> 使得 <span class="math inline">\((r_{1}, r_{2})=r_{1}x+r_{2}y\)</span> 即 <span class="math inline">\((a,b)=ax+by\)</span>. 证毕。</p>
<p>利用上面的递推过程我们得到了 extended Euclidean algorithm. 它可以计算出 <span class="math inline">\((a,b)=ax+by\)</span> 的一组整数解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exgcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = exgcd(b, a % b)</span><br><span class="line">        <span class="keyword">return</span> (y, x-(a//b)*y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = exgcd(<span class="number">10319</span>, <span class="number">2312</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x, <span class="string">&#x27;, y =&#x27;</span>, y, <span class="string">&#x27;, gcd =&#x27;</span>, a*x+b*y)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2022/03/10/number-theory-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/10/number-theory-notes/" class="post-title-link" itemprop="url">Number theory notes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-10 11:34:00" itemprop="dateCreated datePublished" datetime="2022-03-10T11:34:00+08:00">2022-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="euclidean">Euclidean</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Modular_arithmetic">Modular arithmetic</a> is congruence, meaning that it is an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Equivalence_relation" title="Equivalence relation">equivalence relation</a> that is compatible with the operations of addition, subtraction, and multiplication.</p>
<p><span class="math display">\[
\left.
\begin{array}{ll}
a\equiv b \pmod {n}\\
c\equiv d \pmod {n}
\end{array}
\right\} \implies a-c \equiv b-d \pmod {n}
\]</span></p>
<p>The Euclidean algorithm just flows out:</p>
<p><span class="math display">\[
\left.
\begin{array}{ll}
a \equiv 0 \pmod {d}\\
b \equiv 0 \pmod {d}
\end{array}
\right\} \implies a-kb \equiv 0 \pmod {d}
\]</span></p>
<p>For all <span class="math inline">\(d \in \mathbb{N}^+\)</span>, <span class="math inline">\(k \in \mathbb{Z}\)</span>, if <span class="math inline">\(d \mid a\)</span> (<span class="math inline">\(d\)</span> is a divisor of <span class="math inline">\(a\)</span>), <span class="math inline">\(d \mid b\)</span> (<span class="math inline">\(d\)</span> is a divisor of <span class="math inline">\(b\)</span>) and <span class="math inline">\(a \geq b\)</span> then <span class="math inline">\(d \mid a-kb\)</span>. Thus we see that <span class="math inline">\(gcd(a,b)=gcd(b, a \bmod b)\)</span>.</p>
<p>To describe and proof the algorithm, we can define an array <span class="math inline">\(r\)</span> such that <span class="math inline">\(r_0=a\)</span> and <span class="math inline">\(r_1=b\)</span>, while</p>
<p><span class="math display">\[
r_{j}=r_{j-2} \bmod r_{j-1}
\]</span></p>
<p>It basically means</p>
<p><span class="math display">\[
r_{j-2} = r_{j-1}q_{j-1} + r_{j}
\]</span></p>
<p>where <span class="math inline">\(q_{j-1}= [r_{j-2} / r_{j-1}]\)</span> stands for quotient. When hit <span class="math inline">\(r_{n-1} \bmod r_n = 0\)</span>, we stop. Thus <span class="math inline">\(r_{n+1}=0\)</span>.</p>
<p>Therefore</p>
<p><span class="math display">\[
\begin{gather*}
gcd(r_j, r_{j+1})=gcd(r_{j+1}, r_{j+2})\\
r_n= gcd(r_n, 0) = \cdots = gcd(r_0, r_1)
\end{gather*}
\]</span></p>
<p>Let <span class="math inline">\(g=gcd(a,b)\)</span>, notice that</p>
<p><span class="math display">\[
\begin{align*}
g=gcd(r_n,0) &amp;= 1\times r_n + 0\times r_{n+1}=r_n\\
&amp;=r_{n-2}-q_{n-1}r_{n-1}\\
&amp;=r_{n-2}-q_{n-1}(r_{n-3}-r_{n-2}q_{n-2})\\
&amp;=q_{n-1}r_{n-3}+(1+q_{n-2}q_{n-1})r_{n-2}\\
&amp;=\cdots
\end{align*}
\]</span></p>
<p>We may wonder if there exists a linear combination such that <span class="math inline">\(g=ax+by\)</span>. In fact, this is what Bezout's theorem says.</p>
<p><strong>Proof</strong> by induction.</p>
<p><em>Base case:</em></p>
<p><span class="math display">\[
g= 1\times r_n + 0\times r_{n+1}
\]</span></p>
<p><em>Induction step:</em></p>
<p>Given that <span class="math inline">\(r_{j+1}=r_{j-1}-r_{j}q_{j}\)</span></p>
<p><span class="math display">\[
\begin{align*}
g&amp;=r_{j}x_{j}+r_{j+1}y_{j}\\
&amp;=r_{j}x_{j}+(r_{j-1}-r_{j}q_{j})y_{j}\\
&amp;=r_{j-1}y_{j}+r_{j}(x_{j}-q_{j}y_{j})
\end{align*}
\]</span></p>
<p>So <span class="math inline">\(x_{j-1}=y_{j}, y_{j-1}=x_j-q_jy_j\)</span>.</p>
<p>Finally,</p>
<p><span class="math display">\[
g=r_0x_0+r_1y_0=ax_0+by_0
\]</span></p>
<p>This also provides us an algorithm to produce a linear combination.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exgcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = exgcd(b, a % b)</span><br><span class="line">        <span class="keyword">return</span> (y, x-(a//b)*y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = exgcd(<span class="number">10319</span>, <span class="number">2312</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x, <span class="string">&#x27;, y =&#x27;</span>, y, <span class="string">&#x27;, gcd =&#x27;</span>, a*x+b*y)</span><br></pre></td></tr></table></figure>
<p>References:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/euclidean-algorithm.article.pdf">The Euclidean Algorithm</a></li>
</ul>
<h2 id="linear-congruences">Linear Congruences</h2>
<p>Suppose you want to solve</p>
<p><span class="math display">\[
ax \equiv c \pmod b
\]</span></p>
<p>and you need to find the minimum integer <span class="math inline">\(x\)</span>.</p>
<p>First we can translate it to a normal equation.</p>
<p><span class="math display">\[
ax \equiv c \pmod b \iff ax - c = by
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2022/02/20/euler-totient-theorem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/20/euler-totient-theorem/" class="post-title-link" itemprop="url">Euler's Totient Theorem</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-20 12:21:00" itemprop="dateCreated datePublished" datetime="2022-02-20T12:21:00+08:00">2022-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本篇为交互式 Jupyter Notebook 文档，请在 <a target="_blank" rel="noopener" href="https://note.stay-curious.win/">这里</a> 查看完整版。</p>
</blockquote>
<p>由于叫 欧拉定理 的定理太多所以就用这个名字了。</p>
<p>在开始讲解之前，首先要问这么一个问题：</p>
<p><span class="math inline">\(3^{2012} \bmod 17\)</span>是多少？</p>
<p>看到取模，我们当然要先找找规律：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">3</span>**exponent%<span class="number">17</span> <span class="keyword">for</span> exponent <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>)])</span><br><span class="line"><span class="built_in">print</span>([<span class="number">3</span>**exponent%<span class="number">17</span> <span class="keyword">for</span> exponent <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>, <span class="number">33</span>)])</span><br></pre></td></tr></table></figure>
<p>啊哈！3的幂对17取模，结果是循环的。</p>
<p>所以 <span class="math inline">\(2012 = 125 \cdot 16 + 12\)</span>，<span class="math inline">\(3^{2012} \equiv 3^{12} \equiv 4 \pmod {17}\)</span>.</p>
<p>我们应该再仔细思考一下，为什么是以16个数为一循环？</p>
<p>因为一个数对17取模，得到的结果只可能在 <span class="math inline">\([0, 16]\)</span> 这个区间上。而如果一个结果是0，那么其他结果全是0，所以只能在 <span class="math inline">\([1, 16]\)</span> 上。</p>
<p>那无论底数是什么，都是16个数一循环吗？一定会形成循环吗？</p>
<p>首先来看后面这个问题，答案是会。因为一定会有重复，有重复就会出现循环。</p>
<p><span class="math display">\[
3^{x} \equiv 3^{y} \pmod {17} \iff 3^{x+1} \equiv 3^{y+1} \pmod {17}
\]</span></p>
<p>对于前一个问题，鉴于有重复就会出现循环，一个循环里面不可能有重复。总共只有16个数，根据鸽巢原理，循环的长度一定小于等于16. 问题也等价于：<span class="math inline">\([1, 16]\)</span> 中的每一个数都会出现吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">2</span>**exponent%<span class="number">17</span> <span class="keyword">for</span> exponent <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>)])</span><br></pre></td></tr></table></figure>
<p>看来并不是。那么接下来怎么办呢？</p>
<p>我们不如换一种思路，看看有没有哪个数是一定会出现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">17</span>):</span><br><span class="line">    <span class="built_in">print</span>(base, [base**exponent%<span class="number">17</span> <span class="keyword">for</span> exponent <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>)])</span><br></pre></td></tr></table></figure>
<p>令人惊奇的是，每个数的第16次方对17取余，结果都是1. 也即</p>
<p><span class="math display">\[
a^{16} \equiv 1 \pmod {17}
\]</span></p>
<p>联想到上面我们证明循环等价于重复的公式：</p>
<p><span class="math display">\[
a^{16} \equiv 1 \pmod {17} \iff a^{16+1} \equiv a \pmod {17}
\]</span></p>
<p>我们如果可以证明上式右边成立，我们就能证明无论如何第1到第16个数都会形成循环了。</p>
<p>作为严谨证明的大纲，先演示对于一个特殊情况：<span class="math inline">\(a=3\)</span>，模数为 7 的证明。</p>
<p>我们先看一个引理：如果我们有正整数 <span class="math inline">\(p\)</span> 并且它不被另一个正整数 <span class="math inline">\(a\)</span> 整除，我们可以写下这样的数列</p>
<p><span class="math display">\[
a, 2a, 3a, \cdots , (p-1)a
\]</span></p>
<p>我们对这数列的每一项都对 <span class="math inline">\(p\)</span> 取余，就能得到一个从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(p-1\)</span> 的全排列。也就是说，每个数都会出现一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">p = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>([a*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p)])</span><br><span class="line"><span class="built_in">print</span>(perm := [a*i%p <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p)])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(perm))</span><br></pre></td></tr></table></figure>
<p>在这之后，我们会把这两个数列分别乘起来。由于前者只是后者的 <span class="math inline">\(a\)</span> 倍，所以它们模 <span class="math inline">\(p\)</span> 同余。</p>
<p><span class="math display">\[
a \times 2a \times 3a \times \cdots \times (p-1)a \equiv 1 \times 2 \times 3 \times \cdots \times (p-1) \pmod p
\]</span></p>
<p>化简得到</p>
<p><span class="math display">\[
a^{p-1}(p-1)! \equiv (p-1)! \pmod p
\]</span></p>
<p>最后，我们会把两边的 <span class="math inline">\((p-1)!\)</span> “消去”（我知道不能这么直接消，bear with me!）得到</p>
<p><span class="math display">\[
a^{p-1} \equiv 1 \pmod p
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lhs = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p):</span><br><span class="line">    lhs *= a*i</span><br><span class="line">rhs = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p):</span><br><span class="line">    rhs *= i</span><br><span class="line"><span class="built_in">print</span>(lhs, <span class="string">&#x27;===&#x27;</span>, rhs, <span class="string">&#x27;(mod &#x27;</span> + <span class="built_in">str</span>(p) + <span class="string">&#x27;) is&#x27;</span>, lhs%<span class="number">7</span> == rhs%<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canceling out (p-1)! gives us:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lhs//rhs, <span class="string">&#x27;=== 1 (mod &#x27;</span> + <span class="built_in">str</span>(p) + <span class="string">&#x27;) is&#x27;</span>, (lhs/rhs)%<span class="number">7</span> == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>要完成这个证明，有两个地方需要我们详细说明：</p>
<ul>
<li>引理：如果我们有正整数 <span class="math inline">\(p\)</span> 并且它不被另一个正整数 <span class="math inline">\(a\)</span> 整除，<span class="math inline">\(i\)</span> 为正整数且 <span class="math inline">\(i \leq p-1\)</span> 时，<span class="math inline">\(\{ia\bmod p\} = \{i\}\)</span></li>
<li>同余式两边何时能同时消去一个数</li>
</ul>
<p>我们先看第二个：同余式除法，因为第一个依赖第二个证明。</p>
<p>上面我们已经用了同余式两边同时乘上同余的数，同余式仍然成立的性质。除此之外对于加减法也有效。但是对于除法，就没那么简单了。</p>
<p>首先把同余式写成等式。</p>
<p><span class="math display">\[
ac \equiv bc \pmod m \iff \exists k \in \mathbb{Z}, ac = bc + km
\]</span></p>
<p>右式两边同时除以 <span class="math inline">\(c\)</span> 得</p>
<p><span class="math display">\[
a = b + \frac{km}{c}
\]</span></p>
<p>如果 <span class="math inline">\(c \nmid m\)</span> 那么我们还需要换掉整数 <span class="math inline">\(k\)</span> 以使模数为一个整数。</p>
<p><span class="math display">\[
\begin{aligned}
k&#39; &amp;= \frac{k \cdot gcd(m, c)}{c} \\
a &amp;= \frac{k&#39;m}{gcd(m, c)}
\end{aligned}
\]</span></p>
<p>最后得到</p>
<p><span class="math display">\[
ac \equiv bc \pmod m \iff a \equiv b \ \left(\bmod \frac{m}{gcd(m, c)} \right)
\]</span></p>
<p>如果我们希望前后模数相等，当且仅当 <span class="math inline">\(gcd(m, c) = 1\)</span> 也即 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(c\)</span> 互质才成立。</p>
<p>回到刚才的这个式子</p>
<p><span class="math display">\[
a^{p-1}(p-1)! \equiv (p-1)! \pmod p
\]</span></p>
<p>要让两边消掉 <span class="math inline">\((p-1)!\)</span> 又不改变模数，有且仅有 <span class="math inline">\((p-1)!\)</span> 与 <span class="math inline">\(p\)</span> 互质，这等价于 <span class="math inline">\(p\)</span> 为一个质数。7 和 17 都满足这个要求。</p>
<p>现在再来看那个引理：如果有正整数 <span class="math inline">\(p\)</span> 并且它不被另一个正整数 <span class="math inline">\(a\)</span> 整除，<span class="math inline">\(i\)</span> 为正整数且 <span class="math inline">\(i \leq p-1\)</span> 时，<span class="math inline">\(\{ia\bmod p\} = \{i\}\)</span>.</p>
<p>首先，小于 <span class="math inline">\(p\)</span> 的数 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(p\)</span> 互质，而 <span class="math inline">\(a\)</span> 也与 <span class="math inline">\(p\)</span> 互质，所以这两个数乘起来仍然与 <span class="math inline">\(p\)</span> 互质（欧几里得引理）。所以 <span class="math inline">\(ia \bmod p \in [1, p-1]\)</span>. 然后要证明这些数互不相等。运用反证法，假设有两个不相等的数 <span class="math inline">\(x,y &lt; i\)</span> 使得</p>
<p><span class="math display">\[
xa \equiv ya \pmod p
\]</span></p>
<p>那么由上面推导的同余式除法得</p>
<p><span class="math display">\[
x \equiv y \pmod p
\]</span></p>
<p>而 <span class="math inline">\(x&lt;i, y&lt;i\)</span> 所以 <span class="math inline">\(x=y\)</span> 与假设矛盾。证毕。</p>
<p>至此，证明全部完成。</p>
<p>由上面的推导，我们得到了费马小定理：</p>
<blockquote>
<p>对于质数 <span class="math inline">\(p\)</span> 以及任意正整数 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(p \nmid a\)</span> 有</p>
<p><span class="math display">\[
a^{p-1} \equiv 1 \pmod p
\]</span></p>
</blockquote>
<p>如果你足够细心，你也许会注意到我刚才说第二点的时候并没有提到 <span class="math inline">\(p\)</span> 一定是个素数。这让我们不禁想推广刚才得到的成果。我们先来感性的认识一下，当 <span class="math inline">\(p\)</span> 不是素数时是什么样的。因为 <span class="math inline">\(p\)</span> 是 prime 的意思，所以下面换成合数的情况下我们用 <span class="math inline">\(m\)</span> 来代替。</p>
<p>我们先来看看 <span class="math inline">\(m=10\)</span> 的情形：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_repeat</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr[<span class="number">1</span>:]):</span><br><span class="line">        <span class="keyword">if</span> arr[<span class="number">0</span>] == value:</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>:index+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>, m):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, arr := [a**exponent%m <span class="keyword">for</span> exponent <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m)], extract_repeat(arr))</span><br></pre></td></tr></table></figure>
<p>注意到，当 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(m\)</span> 有公因数的时候，循环不一定会出现 1. 这是为什么呢？任意整数 <span class="math inline">\(k\)</span>，<span class="math inline">\(km+1\)</span> 这时候都肯定跟 <span class="math inline">\(m\)</span> 互质，因此 <span class="math inline">\(a^{x} \neq km+1\)</span>.</p>
<p>有没有整数 <span class="math inline">\(a,x\)</span> 使得</p>
<p><span class="math display">\[
a^x \equiv 1 \pmod m
\]</span></p>
<p>呢？要找到这个数，我们就得找到一个数列 <span class="math inline">\(T\)</span>，使其满足我们上面的两点要求</p>
<ul>
<li>对每个数乘以 <span class="math inline">\(a\)</span> 再 <span class="math inline">\(\bmod \ m\)</span> 得到的数列是 <span class="math inline">\(T\)</span> 的全排列</li>
<li>把 <span class="math inline">\(T\)</span> 中的数全乘起来，得到的数与 <span class="math inline">\(m\)</span> 互质（可以从同余式两边消去）</li>
</ul>
<p>在 <span class="math inline">\(m = p\)</span> 的情况下，我们已经看到了 <span class="math inline">\(T=\{1,2,3,\cdots,p-1\}\)</span>. 现在考虑的是 <span class="math inline">\(m\)</span> 不为质数的情况。</p>
<p>先看第一点。需要 <span class="math inline">\(T\)</span> 中的数 <span class="math inline">\(t_i\)</span> 都与 <span class="math inline">\(m\)</span> 互质，<span class="math inline">\(a\)</span> 与 <span class="math inline">\(m\)</span> 互质，以及 <span class="math inline">\(t_ia \bmod m \in T \implies T\)</span> 是比 <span class="math inline">\(m\)</span> 小且与 <span class="math inline">\(m\)</span> 互质的数的集合。</p>
<p>再看第二点，由 <span class="math inline">\(T\)</span> 是与 <span class="math inline">\(m\)</span> 互质的数的集合，<span class="math inline">\(T\)</span> 中的数全乘起来，得到的数与 <span class="math inline">\(m\)</span> 互质，满足条件。</p>
<p>下面开始外层证明。令 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(T\)</span> 中所有数的乘积，即 <span class="math inline">\(r = \prod t_i\)</span>. <span class="math inline">\(\phi(m)\)</span> 为 <span class="math inline">\(m\)</span> 对应的数组 <span class="math inline">\(T\)</span> 中的元素个数。</p>
<p><span class="math display">\[
\begin{aligned}
at_1 \times at_2 \times \cdots \times at_n &amp;\equiv t_1 \times t_2 \times \cdots \times t_n \pmod m \\
a^{\phi(m)} r &amp;\equiv r \pmod m \\
a^{\phi(m)} &amp;\equiv 1 \pmod m
\end{aligned}
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">m</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> math.gcd(k, m) == <span class="number">1</span>:</span><br><span class="line">            res.append(k)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">arr</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> arr:</span><br><span class="line">        res *= t</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line">T = phi(m)</span><br><span class="line">r = prod(T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(prod([a*t <span class="keyword">for</span> t <span class="keyword">in</span> T]), <span class="string">&#x27;===&#x27;</span>, r, <span class="string">&#x27;(mod &#x27;</span> + <span class="built_in">str</span>(m) + <span class="string">&#x27;) is&#x27;</span>, prod([a*t <span class="keyword">for</span> t <span class="keyword">in</span> T])%m == r%m)</span><br><span class="line"><span class="built_in">print</span>(a**<span class="built_in">len</span>(T)*r, <span class="string">&#x27;===&#x27;</span>, r, <span class="string">&#x27;(mod &#x27;</span> + <span class="built_in">str</span>(m) + <span class="string">&#x27;) is&#x27;</span>, a**<span class="built_in">len</span>(T)*r%m == r%m)</span><br><span class="line"><span class="built_in">print</span>(a**<span class="built_in">len</span>(T) , <span class="string">&#x27;=== 1&#x27;</span>, <span class="string">&#x27;(mod &#x27;</span> + <span class="built_in">str</span>(m) + <span class="string">&#x27;) is&#x27;</span>, a**<span class="built_in">len</span>(T)%m == <span class="number">1</span>%m)</span><br></pre></td></tr></table></figure>
<p>这就证明了欧拉定理（数论）：</p>
<blockquote>
<p><span class="math inline">\(m\)</span> 和 <span class="math inline">\(a\)</span> 是互质的正整数，<span class="math inline">\(\phi(m)\)</span> 为小于等于 <span class="math inline">\(n\)</span> 的正整数中与 <span class="math inline">\(n\)</span> 互质的数的数目（欧拉函数），有</p>
<p><span class="math display">\[
a^{\phi(m)} \equiv 1 \pmod m
\]</span></p>
</blockquote>
<p>参考资料：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.math.cmu.edu/~mlavrov/arml/12-13/number-theory-11-11-12.pdf">Euler’s Totient Theorem, Misha Lavrov[PDF]</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem#Proof_as_a_particular_case_of_Euler&#39;s_theorem">Proofs of Fermat's little theorem, Wikipedia</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/12/15/front-end-article-recommendation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/15/front-end-article-recommendation/" class="post-title-link" itemprop="url">前端入门好文推荐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-15 23:43:00" itemprop="dateCreated datePublished" datetime="2021-12-15T23:43:00+08:00">2021-12-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近一周简单学了下 React 和 JavaScript，把遇到的各种难点整理一下，附上我能找到的好文：</p>
<h2 id="javascript">JavaScript</h2>
<p>通用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/">现代 JavaScript 教程</a>（The Modern JavaScript Tutorial）</li>
</ul>
<p>理解 this 和函数调用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and "this"</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904113352736776">this绑定的四种方式：new，显式，隐式，默认</a></li>
</ul>
<p>理解箭头函数</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数 - MDN</a></li>
</ul>
<p>面向对象</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022776150">JS中的构造函数、原型、原型链</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链 - MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/">Understanding "Prototypes" in JavaScript</a></li>
</ul>
<p>模块</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/javascript-modules-a-beginner-s-guide-783f7d7a5fcc/#.jw1txw6uh">JavaScript Modules: A Beginner’s Guide</a></li>
</ul>
<p>函数式编程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide">Mostly adequate guide to functional programming (in javascript)</a>（<a target="_blank" rel="noopener" href="https://github.com/llh911001/mostly-adequate-guide-chinese">中文译版</a>）</li>
</ul>
<h2 id="css">CSS</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040718161">10个好用的的css框架</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/taniarascia/primitive">Primitive UI</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/material-design-lite">Material Design Lite</a></li>
</ul>
<h2 id="react">React</h2>
<p>官方文档作为入门资料已经很好了。下面是进阶补充，主要是思想介绍：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2020/09/react-hooks-useeffect-tutorial.html">轻松学会 React 钩子：以 useEffect() 为例</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/react-guide/react-basic">React 设计思想</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/424391079">奇葩说框架之React编译原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/react-art-of-simplity/">深入浅出 React</a> （<a target="_blank" rel="noopener" href="https://www.kancloud.cn/kancloud/react-in-depth/47779">看云文档</a>）</li>
<li><a target="_blank" rel="noopener" href="https://reactpatterns.com/">React Patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040272535">React 并发功能体验-前端的并发模式已经到来。</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/12/04/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/04/dynamic-programming/" class="post-title-link" itemprop="url">简析动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 15:37:00" itemprop="dateCreated datePublished" datetime="2021-12-04T15:37:00+08:00">2021-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
</blockquote>
<p>动态规划是一种在 OI 中非常常见的算法。如上所述，动态规划的精髓在于<strong>子问题</strong>，然而并不是所有和子问题相关的算法都是动态规划。要搞清楚动态规划<strong>是什么、为什么、怎么用</strong>，我们可以从两种方向来认识。</p>
<h2 id="重叠子问题">重叠子问题</h2>
<p><em>例题1：</em></p>
<p>蒜头君很喜欢爬楼梯，这一次，他获得了一个特异功能，每次可以跳跃任意奇数的阶梯。比如他初始在楼底，跨越一个阶梯到达 11 号阶梯，或者跨越 3 个楼梯到达 3 号阶梯。如下图</p>
<figure>
<img src="https://res.jisuanke.com/img/upload/20180403/3110ec4f381651d86db508f2d5968c721a65e126.png" alt="蒜头君爬楼梯" /><figcaption aria-hidden="true">蒜头君爬楼梯</figcaption>
</figure>
<p>为了选出一种最轻松的爬楼梯的方式，蒜头君想把所有不同的到达楼顶的方式都尝试一遍。对于一共有 <span class="math inline">\(n\)</span> 个阶梯的楼梯，蒜头君一共有多少种方法从楼底到达楼顶？</p>
<p>最暴力的做法就是递归搜一遍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">path</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; n - i &gt;= <span class="number">0</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">path</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 <span class="math inline">\(O(n!)\)</span>，但其实这离答案就差一点。</p>
<p><strong>Tips:</strong> 你要知道第 <span class="math inline">\(n\)</span> 个阶梯的方案数，你只需要知道到第 <span class="math inline">\(n-1\)</span>, <span class="math inline">\(n-3\)</span>, <span class="math inline">\(n-5\)</span>…… 个阶梯的方案数。</p>
<p>我怎么知道？存下来就行了呗：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll memory[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">path</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memory[n]) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; n - i &gt;= <span class="number">0</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">path</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        memory[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来，时间复杂度就变成 <span class="math inline">\(O(n)\)</span> 了。</p>
<p>思路：因为 <span class="math display">\[
path_{n} =path_{n-1} +path_{n-3}+...+path_{n-(2k-1)}
\]</span> 所以用数组记录每个子问题的解以避免重复计算。</p>
<p>这就是<strong>重叠子问题</strong>，通过对重叠子问题的记忆，可以极大地优化很暴力的算法。</p>
<p>重叠子问题，在编程层面上常常表现为<strong>纯函数</strong>。如果你曾经接触过函数式编程（比如使用 React 之类的库或者 Haskell 语言），你可能听说过这个概念。纯函数是一个满足以下条件的函数：</p>
<ul>
<li>输入参数相同时，输出值相同。</li>
<li>不能有语义上可观察的副作用，比如更改输出值以外变量的内容等。</li>
</ul>
<p>上文所述 <code>path</code> 函数正好满足这些要求。因此，我们可以放心地根据参数缓存它的返回值。</p>
<h2 id="最优子结构">最优子结构</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">Leetcode 最小路径和</a></p>
<p>给定一个包含非负整数的 <span class="math inline">\(m\times n\)</span> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>同样先用递归写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_path</span>(x, y - <span class="number">1</span>) + grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_path</span>(x - <span class="number">1</span>, y) + grid[x][y];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min_path</span>(x - <span class="number">1</span>, y), <span class="built_in">min_path</span>(x, y - <span class="number">1</span>)) + grid[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在肯定在想：记忆化！开个数组 <code>min_path[x][y]</code> 把遍历到的结果全存下来，如果已经算过直接返回不就行了！</p>
<p>先等一下，我们先想想，这个 <code>min_path</code> 函数在语义上是什么用途呢？是从 <span class="math inline">\((1,1)\)</span> 前往 <span class="math inline">\((x,y)\)</span> 的最小距离。那你怎么就肯定 <span class="math inline">\((x,y)\)</span> 变了以后，你存下来的还是对应的最短距离呢？</p>
<p>换句话说，记忆化的前提是：无论终点是哪一个，到达终点的路径上的点之间走的<strong>全部都是最短距离</strong>，不存在有需要绕路的情况。</p>
<p>这就是<strong>最优子结构</strong>。一个解是最优的，那么它在子问题中也必定是最优的。</p>
<p>再看一道题：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a></p>
<p>简单写个<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/64333237">暴力递归</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">351</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">121</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXM];</span><br><span class="line"><span class="type">bool</span> used[MAXM];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_scores</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[x];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max_scores</span>(x - b[i]) + a[x]);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="built_in">sizeof</span>(used));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max_scores</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，还能记忆化吗？</p>
<p>不行了。因为函数返回的值不但跟终点位置 <code>x</code> 有关，还跟使用爬行卡片情况的数组 <code>used</code> 有关。显然，这个函数不满足上面所说纯函数的两个要求。如果你把 <code>used</code> 也当成参数加进来，那么每次 <code>used</code> 的值都会不同，记忆化没有意义。</p>
<p>这是为什么呢？原因就是现在我们的函数 <code>max_scores(int x)</code> 不具有最优子结构了。当前贪心地把前 <code>x</code> 个格子的分数拿到最大用掉了爬行卡片，后面就会受影响得不到最优的结果。正是因为有了最优子结构，子问题才会重叠。<strong>最优子结构是因，重叠子问题是果。</strong></p>
<p>那，这题就不能用动态规划做了？</p>
<p>仔细观察题目：</p>
<blockquote>
<p>分成4种不同的类型（<span class="math inline">\(M\)</span> 张卡片中不一定包含所有 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1, 2, 3, 4 四个数字之一。</p>
</blockquote>
<p>总共只有四种类型的卡片，而相同数字的卡片没有任何区别。重叠子问题！写一下试试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">351</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">121</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXB = <span class="number">41</span>;</span><br><span class="line"><span class="type">int</span> score[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> memory[MAXB][MAXB][MAXB][MAXB];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_scores</span><span class="params">(<span class="type">int</span>* use)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; use[<span class="number">3</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> score[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">1</span>;  <span class="comment">// start from 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            x += use[i] * (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (use[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                use[i]--;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max_scores</span>(use) + score[x]);</span><br><span class="line">                use[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory[use[<span class="number">0</span>]][use[<span class="number">1</span>]][use[<span class="number">2</span>]][use[<span class="number">3</span>]] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; score[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        cnt[--b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max_scores</span>(cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/64361130">顺利 AC</a>. 我们可以发现，选取递归函数的参数和语义是解决此问题的关键。</p>
<p>虽然这个函数在形式上仍然不满足纯函数的要求，但是这仅仅是为了方便。你完全可以用更加啰嗦的形式，将参数由一个数组指针改成四个整型，把这个函数改造成一个纯函数。</p>
<h2 id="形式不重要">形式不重要</h2>
<p>动态规划在狭义上一般都是从最小的子问题开始，一步一步求解更大规模的问题，所以它的实现都是循环，而不是递归。然而，上面讲的全部都是递归，这种方法会被单独称作<strong>记忆化搜索</strong>。但是我这么做的原因正是想说明一点：形式不重要，重要的是子问题的解之间的依赖关系。</p>
<p>这里引用<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290/answer/96997659">知乎上的一篇回答</a>：</p>
<blockquote>
<p>动态规划的初衷是，</p>
<p>通过找到合适的角度，将所求解的目标值在某（几）个维度上展开，使得最终的目标能变成一个函数在某组自变量下的值：比如在经典题目数字三角形中，将“和”在“横纵坐标”上展开，那么最终的目标就是 <span class="math inline">\(max\{f(n - 1, i)\}\)</span>，<span class="math inline">\(i\)</span> 从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n-1\)</span>.</p>
<p>这种展开需要满足的性质是：首先，展开后，函数值是可以由自变量唯一确定的；其次，函数有一种递推表达式；最后，可以通过某种求值顺序（待求的所有函数值的依赖关系形成一个有向无环图），从显然的初值开始依次求，直到目标值。</p>
<p>至于是用循环解，还是记忆化搜索解，还是用 BFS 或者 DFS 解，都不本质。这个依赖于上文所说的有向无环图的结构。</p>
</blockquote>
<p>而求解这个问题，正是遍历这张有向无环图上和答案点直接或间接相连的所有点。</p>
<p>我们可以用最暴力的方法去递归，这就对应着在那个有向无环图中从我们要求解的那个点开始，完全按照有向边走。可以想见，这么走必定会大量重复经过点，这就是它低效的原因。</p>
<p>那我们可以怎么优化呢？记忆化搜索给出的答案是把走过的点的结果存起来，下一次就不往下走了，这样就避免了绝大部分重复经过的情况。</p>
<p>而使用循环的动态规划则是从最底部已知的边界点开始，倒着往上遍历。它并不依赖图之间的有向边遍历，而是按照预设好的路线遍历。这就需要保证遍历到的每个点的依赖都已被遍历。</p>
<p>所以说，能用动态规划求解的问题一定能用记忆化搜索求解。</p>
<p>计算机只会穷举。所有算法都是在<strong>充分利用给定的条件</strong>，让计算机<strong>更优雅地</strong>穷举。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/12/02/flarum-setup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/02/flarum-setup/" class="post-title-link" itemprop="url">安装和配置 Flarum</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-02 11:45:00" itemprop="dateCreated datePublished" datetime="2021-12-02T11:45:00+08:00">2021-12-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文采用 Ubuntu 20.04 LTS.</p>
<h2 id="安装-mariadbphp-和-composer">安装 MariaDB、PHP 和 Composer</h2>
<p>更新源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>首先安装 php（Apache 2 的 php 模块）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 mariadb-server php7.4 libapache2-mod-php7.4 php7.4-common php7.4-mbstring php7.4-xmlrpc php7.4-soap php7.4-mysql php7.4-gd php7.4-xml php7.4-curl php7.4-cli php7.4-zip php7.4-tokenizer wget unzip curl git -y</span><br></pre></td></tr></table></figure>
<p>然后全局安装 Composer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">sudo <span class="built_in">mv</span> composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>
<h2 id="配置数据库">配置数据库</h2>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<ul>
<li>Enter current password for root (enter for none): Just press the Enter</li>
<li>Set root password? [Y/n]: Y</li>
<li>New password: Enter password</li>
<li>Re-enter new password: Repeat password</li>
<li>Remove anonymous users? [Y/n]: Y</li>
<li>Disallow root login remotely? [Y/n]: Y</li>
<li>Remove test database and access to it? [Y/n]: Y</li>
<li>Reload privilege tables now? [Y/n]: Y</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br><span class="line">create database flarum character set utf8mb4 collate utf8mb4_unicode_ci;</span><br><span class="line">CREATE USER &#x27;flarumuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password_here&#x27;;</span><br><span class="line">GRANT ALL ON flarum.* TO &#x27;flarumuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;user_password_here&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure>
<h2 id="安装-flarum-并配置-apache">安装 Flarum 并配置 Apache</h2>
<p>创建目录并使当前用户成为所有者。这是为了避免以 root 运行 Composer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/flarum</span><br><span class="line">sudo chown -R $USER:$USER /var/www/flarum</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/flarum</span><br><span class="line">composer create-project flarum/flarum .</span><br></pre></td></tr></table></figure>
<p>然后，使 Apache 成为该目录的所有者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R www-data:www-data /var/www/flarum</span><br></pre></td></tr></table></figure>
<p>添加 Apache 的 VirtualHost</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/flarum.conf</span><br></pre></td></tr></table></figure>
<p>写入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin admin@your_domain.com</span><br><span class="line">    DocumentRoot /var/www/flarum/public</span><br><span class="line">    ServerName your-server</span><br><span class="line">    &lt;Directory /var/www/flarum/public&gt;</span><br><span class="line">        Options FollowSymlinks</span><br><span class="line">        AllowOverride All</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    ErrorLog $&#123;APACHE_LOG_DIR&#125;/your-domain.com_error.log</span><br><span class="line">    CustomLog $&#123;APACHE_LOG_DIR&#125;/your-domain.com_access.log combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>启用新的 VirtualHost 和 URL 重写模块，并通过重启服务来应用更改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite flarum</span><br><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo a2dissite 000-default.conf</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>
<p>检查是否已打开防火墙。</p>
<h2 id="配置-https">配置 HTTPS</h2>
<p>安装 certbot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install certbot python3-certbot-apache</span><br></pre></td></tr></table></figure>
<p>确保 <code>flarum.conf</code> 中填入了正确的域名。</p>
<p>允许 SSL 通过防火墙</p>
<ul>
<li>检查云服务提供商的防火墙已打开 443 端口</li>
<li>检查 <code>ufw</code> 设置 <code>sudo ufw status</code></li>
</ul>
<p>申请 SSL 证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --apache</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/12/01/common-wa-reasons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/01/common-wa-reasons/" class="post-title-link" itemprop="url">常见 Wrong Answer 原因集锦</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 01:11:00" itemprop="dateCreated datePublished" datetime="2021-12-01T01:11:00+08:00">2021-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="变量运算过程中溢出">变量运算过程中溢出</h2>
<blockquote>
<p>Codeforces <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1609/submission/137522685">#137522685</a></p>
<p>Diagnostics detected issues [cpp.clang++-diagnose]: p71.cpp:66:40: runtime error: signed integer overflow: 99999 * 100000 cannot be represented in type 'int'</p>
</blockquote>
<p>尽管指定运算结果会被赋值/加到一个较大的数据类型（比如 long long），运算过程中仍然会有精度问题。</p>
<p>解决方案：保证所有运算中变量数据类型一致。</p>
<h2 id="stdcout-输出浮点数精度问题"><code>std::cout</code> 输出浮点数精度问题</h2>
<p><code>std::cout &lt;&lt; std::cout.precision();</code> 默认输出为 6. 即最多输出小数点后 6 位。</p>
<p>解决方案：</p>
<ul>
<li><code>std::cout &lt;&lt; std::setprecision(int n)</code></li>
<li><code>printf("pi = %.5f", 4*atan(1.0));</code></li>
</ul>
<h2 id="负数取余取模问题">负数取余取模问题</h2>
<p>在数学上模运算一般是根据欧几里得除法（带余除法）定义的：</p>
<p>对于任意整数 <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> <span class="math inline">\((b\neq 0)\)</span> 存在唯一的整数 <span class="math inline">\(q\)</span> 和 <span class="math inline">\(r\)</span> 使得 <span class="math inline">\(0 \leq r &lt; |b|\)</span> 且</p>
<p><span class="math display">\[
a = bq + r
\]</span></p>
<p>则 <span class="math inline">\(r = a \bmod b\)</span>.</p>
<p>注意，这里规定了 <span class="math inline">\(r \geq 0\)</span>.</p>
<p>对于 <span class="math inline">\(a \geq 0, b &gt; 0\)</span> 的情况，一切正常。</p>
<p>但是如果 <span class="math inline">\(a &lt; 0\)</span> 问题就出现了：</p>
<p><span class="math display">\[
\begin{align*}
-5 &amp;= 3 \cdot (-1) + (-2) \\
-5 &amp;= 3 \cdot (-2) + 1
\end{align*}
\]</span></p>
<p>按照上面的定义 <span class="math inline">\(-5 \bmod 3 = 1\)</span>，但是在 C++ 中结果是 <span class="math inline">\(-2\)</span>.</p>
<p>为什么？这是因为 C++ 的 <code>%</code> 运算符是取余而非取模。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">remainder</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - (a / b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，C99 标准要求，<code>a == b * (a / b) + a % b</code>. 也即 <code>q = a / b</code>，<code>r = a % b</code>.</p>
<p><span class="math inline">\(-5/3 = -1.\dot{6}\)</span>，按照 C++ 的标准去掉小数部分即为 <span class="math inline">\(-1\)</span>. 这就是问题所在：C++ 中的商取整永远都是朝着 0 取。</p>
<p>再来看几个例子：</p>
<p><span class="math display">\[
\begin{align*}
-5 &amp;= (-3) \cdot 1 + (-2)\\
-5 &amp;= (-3) \cdot 2 + 1
\end{align*}
\]</span></p>
<p>而 C++ 中 <code>-5 / -3 = 1</code> 所以 <code>-5 % -3 = -2</code>. 如果商取整朝着负无穷取的话，那么结果的正负号和除数一致。</p>
<p><span class="math display">\[
\begin{align*}
5 &amp;= (-3) \cdot (-1) + 2\\
5 &amp;= (-3) \cdot (-2) - 1
\end{align*}
\]</span></p>
<p>此时 <code>%</code> 运算符和取模匹配。</p>
<p>据此我们可以归纳得出，C++ 中的 <code>%</code> 运算符结果正负号与被除数一致。当被除数大于等于 0 的情况下，<code>%</code> 运算符和取模结果一致。否则需要在结果上加上除数的绝对值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a % b;</span><br><span class="line">    <span class="keyword">return</span> r &lt; <span class="number">0</span> ? r + <span class="built_in">abs</span>(b) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看 Python:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; -5 % 3</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -5 % -3</span><br><span class="line">-2</span><br><span class="line">&gt;&gt;&gt; 5 % -3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>显然 Python 中商取整都是朝着负无穷取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; -5 // 3</span><br><span class="line">-2</span><br><span class="line">&gt;&gt;&gt; -5 // -3</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 5 // -3</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/11/29/self-built-free-blog-the-easy-way/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/self-built-free-blog-the-easy-way/" class="post-title-link" itemprop="url">零编程基础自建免费博客指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-29 04:12:00" itemprop="dateCreated datePublished" datetime="2021-11-29T04:12:00+08:00">2021-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文的标题中强调了“零基础”，但是你仍然需要用到一些常见的开发工具。但请放心，上手使用这些工具并不难！这只需要你有足够的耐心，和一定的信息搜索能力。另外，如果能稍微了解一下原理而不是不求甚解拿来就用，那么维护博客对你来说就更不是件难事。</p>
<h2 id="从这里开始">从这里开始</h2>
<p>Hexo 使用 Markdown 作为文章的格式，所以你需要了解 <a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 标记语言</a> 并选择一个趁手的 Markdown 编辑器。这方面的选择很多，我个人以前一直在用 Typora，但是最近它开始收费了。所以我推荐你用开源的在线 Markdown 编辑器 <a target="_blank" rel="noopener" href="https://markdown.lovejade.cn/?utm_source=markdown.lovejade.cn&amp;pid=about-arya">Arya</a>. 即时预览的界面用起来几乎把学习成本降到了最低。</p>
<h3 id="原理">原理</h3>
<p>为什么 Hexo 的运作不需要服务器呢？其实 Hexo 只干了一件事：把编辑器输出的 Markdown 文档（Microsoft Word 虽然也是这一类文件，但是不被 Hexo 支持）转换成 HTML 5 网页（包括 HTML、CSS、JavaScript）。而这些网页从此就算「独立」了：不需要与生成它的那台机器相连接，它自己就能在任何能打开它的浏览器上工作，也不需要在任何服务器上运行代码。所以，我们只需要给这些网页找一个「网盘」（前提是得支持 HTTP 连接），就能通过访问这个网盘打开网页了。</p>
<p>而是谁运行 Hexo，编译输出网页呢？我们这里用的是 Cloudflare 免费提供的自动构建服务器。你也可以在你自己的计算机上做这个事情，具体操作请看 Hexo 官方文档。</p>
<h2 id="注册">注册</h2>
<p>你需要在两个地方注册账号：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/join">GitHub</a>：与 Git 深度集成，用于存放博客源代码库。</li>
<li><a target="_blank" rel="noopener" href="https://dash.cloudflare.com/sign-up">Cloudflare</a>：用于托管编译出的博客。</li>
</ul>
<p>这两者都只需要邮箱注册。另外尽管这次使用 Cloudflare 提供的托管服务，GitHub 同样也有类似的 GitHub Pages，而它提供的域名其中一部分将是你的用户名。加上用户名注册后不可更改，建议你选一个你喜欢的、好记且好输入的用户名。</p>
<h2 id="配置">配置</h2>
<p>注册完成之后请打开我预先准备好的 <a target="_blank" rel="noopener" href="https://github.com/Richard-Zheng/hexo-next-starter">模板</a>。然后点击 Use this template，填入你的存储库名称（如 <code>blog-source</code>）然后直接点击 Create repository from template.</p>
<p>登入 Cloudflare 控制台，点击右边栏的 Pages，然后点击 Create a project. 再下一个页面中点击 Connect GitHub，授权访问你刚刚创建的存储库（或者所有存储库）。再次回到创建 project 的页面，选中你的存储库并下一步。</p>
<ul>
<li>在 Project name 中填入你博客的名字（将成为你博客域名中的一部分，所以建议你选一个你喜欢的、好记且好输入的名字）</li>
<li>在 Build command 中填入 <code>npm run build</code></li>
<li>在 Build output directory 中填入 <code>public</code></li>
</ul>
<p>其他都保持默认，点击 Save and deploy.</p>
<p>等2到3分钟后，访问 <code>[名字].pages.dev</code>，看看博客是不是已经出现了？</p>
<h2 id="自定义">自定义</h2>
<p>Hexo 的配置是用 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 格式</a> 写的。所以简单了解一下它的格式会极大地帮助你修改配置以及减少出错概率。但是目前来说，你只需要记住以下几点：</p>
<ul>
<li>数据之间的层级关系是通过缩进来体现的，所以你必须严格遵守缩进，且只能使用空格。</li>
<li>单个配置值使用冒号结构表示 <code>key: value</code>，注意冒号后有一个空格。</li>
<li><code>#</code> 开头的为注释</li>
</ul>
<p>准备好后打开你刚刚在 GitHub 上创建的博客存储库，点开主目录下的 <code>_config.yml</code> 文件，然后在文件内容上方的右侧找到修改按钮（图标为一支笔）点开。</p>
<p>这时你就在修改你的 Hexo 配置文件了，这个配置文件的详细说明文档在 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration.html">此处</a>。但如果你没有额外要求，只用改以下几个部分：</p>
<ul>
<li><code>title</code> 网站标题</li>
<li><code>subtitle</code> 网站副标题（可选）</li>
<li><code>author</code> 你的名字</li>
<li><code>url</code> 填入<code>[名字].pages.dev</code></li>
</ul>
<p>填好以后直接点击 Commit changes 提交更改。</p>
<p>可选：然后重复相同的步骤，修改 <code>_config.next.yml</code> 文件，这是主题的配置文件。详细文档在 <a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/getting-started/configuration">此处</a>。你可以参考 <a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/#Choosing-Scheme">文档</a> 挑选一个你喜欢的主题。在大多数情况下，你不需要修改其它的配置。</p>
<p>修改完以后过2到3分钟再次访问你的博客，看看有什么变化？</p>
<h2 id="写作">写作</h2>
<p>你的文章存放在 <code>source/_posts</code> 目录中，修改文章的方式和修改配置基本相同，但是有一点需要注意：每个文章开头都会有这一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2021-01-01 00:00:00 +08:00</span><br><span class="line">tags: [标签1,标签2,标签3]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这个叫做 YAML front matter，其实就是在 Markdown 文件头部加了一段 YAML 格式的配置/说明。你需要注意的是如果文章中有数学公式需要加上一行 <code>mathjax: true</code>。</p>
<p>小技巧：Hexo 会使用每篇文章的文件名作为它的 URL，但是中文出现在 URL 中很不美观，你可以把文章英文名作为 Markdown 文件的名字（全部小写，空格换成短横线，如 <code>hello-world</code>），然后在 <code>title: 你好世界</code> 这里写这篇文章的中文名。实际页面中文章的名字全部取决于这个 <code>title</code> 的值。</p>
<p>如果要新建一篇文章，你可以导航到 <code>source/_posts</code> 目录，然后点击 Add file，选择创建新文件（直接在网页编辑）或是从本地上传 Markdown 文件。</p>
<p>每次博客存储库有更改，在2到3分钟后网站即会更新。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/11/26/template-for-programming-contest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/26/template-for-programming-contest/" class="post-title-link" itemprop="url">算法竞赛常用模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-26 11:44:00" itemprop="dateCreated datePublished" datetime="2021-11-26T11:44:00+08:00">2021-11-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础算法">基础算法</h2>
<h3 id="快速幂">快速幂</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll base, ll exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (exp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<p>给定长度为n的数组（<span class="math inline">\(n\geq 1\)</span>）</p>
<p>问题1：找到值为value的元素的下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 注意防止溢出</span></span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt; value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] &lt; value) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：找到<strong>第一个</strong>值为value的元素的下标</p>
<p>这时候遇到相等也不能直接返回，只能排除掉右侧的所有数。</p>
<p>数组的长度为 1 或 2 时，<code>middle</code>为 0. 若<code>array[0]</code>为要找的数，则<code>right</code>将被赋值为 -1，循环结束，<code>left</code>为答案。数组长度为 2 且<code>array[1]</code>为要找的数时，<code>left</code>将被赋值为 1，回到数组长度为 1 的情况。</p>
<p>因此最后再判断一下<code>left</code>是否为要找的数，如果是则返回，否则答案不存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt;= value) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题3：找到<strong>最后一个</strong>值为value的元素的下标</p>
<p>这就是问题2的倒序版本。改动两个地方即可</p>
<ol type="1">
<li><p><code>if (array[middle] &gt;= value)</code> 中的等号去掉；</p></li>
<li><p><code>if (right &gt;= 0 &amp;&amp; array[right] == value) &#123;return right;&#125;</code></p></li>
</ol>
<p>问题4：找到<strong>第一个大于等于</strong>value的下标</p>
<p>在问题2中，我们的策略是让<code>left</code>刚好为第一个大于等于value的数的下标，而让<code>right</code>刚好为第一个小于value的数的下标。因此只需要去掉最后判断答案存在的<code>array[left] == value</code>条件即可。</p>
<p>问题5：找到<strong>最后一个小于等于</strong>value的下标</p>
<p>与问题4同理，去掉问题3中最后判断答案存在的<code>array[right] == value</code>条件。</p>
<h2 id="数论">数论</h2>
<h3 id="欧拉筛">欧拉筛</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[MAXN];</span><br><span class="line"><span class="type">int</span> prime[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="built_in">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辗转相除法求最大公因数greatest-common-divisor">辗转相除法求最大公因数（Greatest Common Divisor）</h3>
<p>最大公因数的算法是辗转相除法，基于一个原理：如果<span class="math inline">\(a&gt;b\)</span>则<span class="math inline">\(gcd(a,b)=gcd(b,a-b)\)</span>.</p>
<p>如果<span class="math inline">\(a-b&gt;b\)</span>，那么就继续相减到<span class="math inline">\(a-b&lt;b\)</span>为止，所以直接<span class="math inline">\(gcd(a,b)=gcd(b,a\bmod b)\)</span>.</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小公倍数least-common-multiple">最小公倍数（Least Common Multiple）</h3>
<p>两个数的最大公因数（Greatest Common Divisor）就是它们质因数的<strong>交集</strong>的乘积</p>
<p>考虑最小公倍数的性质。最小公倍数必须被<span class="math inline">\(a\)</span>或<span class="math inline">\(b\)</span>​整除，也就是说最小公倍数必须同时包含这两数的所有质因数，所以是它们质因数的<strong>并集</strong>的乘积。怎样得到这个乘积？<span class="math inline">\(a\times b\)</span>，然后容斥除掉共同的质因数<span class="math inline">\(gcd(a,b)\)</span>就好了。 <span class="math display">\[
lcm(a,b)=\dfrac{a\times b}{gcd(a,b)}
\]</span> 实际编程中一般先除后乘，防止溢出。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="裴蜀定理">裴蜀定理</h3>
<p>裴蜀定理，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。</p>
<p>其内容是：</p>
<p>设 <span class="math inline">\(a,b\)</span> 是不全为零的整数，则存在整数 <span class="math inline">\(x,y\)</span>, 使得 <span class="math inline">\(ax+by=\gcd(a,b)\)</span>.</p>
<h4 id="证明">证明：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数返回之前，存在<span class="math inline">\(b=0\)</span>. 这时显然有<span class="math inline">\(x=1,y=0\)</span>使得 <span class="math display">\[
a\cdot 1+0\cdot 0=gcd(a,0)
\]</span> 0 和任何数的最大公约数都等于原数。</p>
<p>当<span class="math inline">\(b&gt;0\)</span>时，有<span class="math inline">\(gcd(a,b)=gcd(b,a\bmod b)\)</span>. 假设存在<span class="math inline">\(x,y\)</span>使得 <span class="math display">\[
bx+(a\bmod b)y=gcd(b,a\bmod b)
\]</span> 且 <span class="math display">\[
a\bmod b=a-b\cdot \left\lfloor \dfrac{a}{b} \right\rfloor
\]</span> 所以 <span class="math display">\[
\begin{aligned}
bx+(a\bmod b)y&amp;=bx+\left(a-b\cdot \left\lfloor \dfrac{a}{b} \right\rfloor\right)y\\
&amp;=ay-b\left(x-\left\lfloor \dfrac{a}{b} \right\rfloor y\right )
\end{aligned}
\]</span> 令<span class="math inline">\(x&#39;=y,\ y&#39;=x-\left\lfloor \dfrac{a}{b} \right\rfloor y\)</span>，可得 <span class="math display">\[
ax&#39;+by&#39;=gcd(a,b)
\]</span> 用归纳法即可得证。</p>
<p>参考：https://www.cnblogs.com/fusiwei/p/11775503.html</p>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>为什么叫它扩展欧几里得呢？因为它就是在欧几里得算法（辗转相除法）求得<span class="math inline">\(gcd(a,b)\)</span>的基础上，像上面裴蜀定理的证明那样倒着回溯找了一组<span class="math inline">\(x,y\)</span>满足 <span class="math display">\[
ax+by=gcd(a,b)
\]</span> 具体代码请看下面的线性同余方程。</p>
<h3 id="线性同余方程线性丢番图方程">线性同余方程（线性丢番图方程）</h3>
<p>形如<span class="math inline">\(ax\equiv c\pmod b\)</span>的方程被称为线性同余方程 (Congruence Equation)。</p>
<h4 id="求解方法">求解方法</h4>
<p>根据以下两个定理，我们可以求出同余方程 <span class="math inline">\(ax \equiv c \pmod b\)</span> 的解。</p>
<p><strong>定理 1</strong>：方程 <span class="math inline">\(ax+by=c\)</span> 与方程 <span class="math inline">\(ax \equiv c \pmod b\)</span> 是等价的，有整数解的充要条件为 <span class="math inline">\(\gcd(a,b) \mid c\)</span>。</p>
<p>根据定理 1，方程 <span class="math inline">\(ax+by=c\)</span>，我们可以先用扩展欧几里得算法求出一组 <span class="math inline">\(x_0,y_0\)</span>，也就是 <span class="math inline">\(ax_0+by_0=\gcd(a,b)\)</span>，然后两边同时除以 <span class="math inline">\(\gcd(a,b)\)</span>，再乘 <span class="math inline">\(c\)</span>。然后就得到了方程 <span class="math inline">\(a\dfrac{c}{\gcd(a,b)}x_0+b\dfrac{c}{\gcd(a,b)}y_0=c\)</span>，然后我们就找到了方程的一个解。</p>
<p><strong>定理 2</strong>：若 <span class="math inline">\(\gcd(a,b)=1\)</span>，且 <span class="math inline">\(x_0\)</span>、<span class="math inline">\(y_0\)</span> 为方程 <span class="math inline">\(ax+by=c\)</span> 的一组解，则该方程的任意解可表示为：<span class="math inline">\(x=x_0+bt\)</span>，<span class="math inline">\(y=y_0-at\)</span>, 且对任意整数 <span class="math inline">\(t\)</span> 都成立。</p>
<p>根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解 <span class="math inline">\(x=(x \bmod t+t) \bmod t\)</span>，其中 <span class="math inline">\(t=\dfrac{b}{\gcd(a,b)}\)</span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">ex_gcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="type">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp - a / b * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">liEu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">ex_gcd</span>(a, b, x, y);</span><br><span class="line">  <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> k = c / d;</span><br><span class="line">  x *= k;</span><br><span class="line">  y *= k;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用-stl">常用 STL</h2>
<h3 id="比较两个-string-是否相等">比较两个 string 是否相等</h3>
<p><a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/string/string/compare/">std::string::compare</a></p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">string (1)</th>
<th><code>int compare (const string&amp; str) const noexcept;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">substrings (2)</td>
<td><code>int compare (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen = npos) const;</code></td>
</tr>
<tr class="even">
<td style="text-align: right;">c-string (3)</td>
<td><code>int compare (const char* s) const; int compare (size_t pos, size_t len, const char* s) const;</code></td>
</tr>
<tr class="odd">
<td style="text-align: right;">buffer (4)</td>
<td><code>int compare (size_t pos, size_t len, const char* s, size_t n) const;</code></td>
</tr>
</tbody>
</table>
<p>返回值</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>value</th>
<th>relation between <em>compared string</em> and <em>comparing string</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td>They compare equal</td>
</tr>
<tr class="even">
<td><code>&lt;0</code></td>
<td>Either the value of the first character that does not match is lower in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is shorter.</td>
</tr>
<tr class="odd">
<td><code>&gt;0</code></td>
<td>Either the value of the first character that does not match is greater in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is longer.</td>
</tr>
</tbody>
</table>
<h3 id="从容器中删除指定的元素">从容器中删除指定的元素</h3>
<p>从字符串中删除某些字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeCharsFromString</span><span class="params">( string &amp;str, <span class="type">char</span>* charsToRemove )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(charsToRemove); ++i ) &#123;</span><br><span class="line">      str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), charsToRemove[i]), str.<span class="built_in">end</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/algorithm/remove/">std::remove</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">remove</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://stay-curious.win/2021/11/13/weird-marks-in-advanced-mathematics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Richard Zheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="湖面">
      <meta itemprop="description" content="人生天地间，忽如远行客。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 湖面">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/13/weird-marks-in-advanced-mathematics/" class="post-title-link" itemprop="url">解读高等数学中那些难懂的符号</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-13 10:53:00" itemprop="dateCreated datePublished" datetime="2021-11-13T10:53:00+08:00">2021-11-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="微分符号和积分符号">微分符号和积分符号</h2>
<p>准备工作：</p>
<ul>
<li>了解极限的定义以及相关的无穷小等概念。</li>
<li>了解导数是什么。</li>
<li>了解极限运算法则和求导法则。</li>
<li>理解“微分是函数的线性近似”</li>
</ul>
<p>很多人都说《高等数学》难学，一部分缘于求极限、求导和积分是全新的、之前没有接触过的运算，要掌握和熟练运用需要不少苦功夫；另一部分就要归结于编书者用“惯例”来搪塞各种解释的高傲态度。</p>
<p>第二章中，先介绍导数，再介绍微分。这导致前面突然就冒出个<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>求导符号。然而介绍微分的时候又草草带过。基本上，书中是这样定义微分运算的：对函数<span class="math inline">\(y=f(x)\)</span>，如果<span class="math inline">\(x_0\)</span>和<span class="math inline">\(x_0+\Delta x\)</span>在定义域内且 <span class="math display">\[
\Delta y=f&#39;\left( x\right) \Delta x+o\left( \Delta x\right)
\]</span> 那么记作 <span class="math display">\[
\mathrm{d}y=A\Delta x.
\]</span> 并且通常把自变量<span class="math inline">\(x\)</span>的增量<span class="math inline">\(\Delta x\)</span>称为自变量的微分，记作<span class="math inline">\(\mathrm{d}x\)</span>，即<span class="math inline">\(\mathrm{d}x=\Delta x\)</span>. 所以函数<span class="math inline">\(y=f(x)\)</span>的微分记作 <span class="math display">\[
\mathrm{d}y=f&#39;(x)\mathrm{d}x.
\]</span> 嗯？这就结束了？</p>
<p>所以微分是什么呢？难道跟我们学的加减乘除一样，就是一个运算符号？</p>
<p>是，也不完全是。</p>
<p>回想书中前面的内容，我们一直把求导符号<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>称为“算子”。其实这个概念在第一章第一节早有介绍，只不过大部分人都会忽略：</p>
<blockquote>
<p>映射又称为<strong>算子</strong>。根据集合<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>的不同情形，在不同的数学分支中，映射又有不同的惯用名称。例如，从非空集<span class="math inline">\(X\)</span>到数集<span class="math inline">\(Y\)</span>的映射又称为<span class="math inline">\(X\)</span>上的<strong>泛函</strong>，从非空集<span class="math inline">\(X\)</span>到它自身的映射又称为<span class="math inline">\(X\)</span>上的<strong>变换</strong>，从实数集（或其子集）<span class="math inline">\(X\)</span>到实数集<span class="math inline">\(Y\)</span>的映射通常定义为<span class="math inline">\(X\)</span>上的<strong>函数</strong>。</p>
</blockquote>
<p>那么求导是怎样的一种映射？显然是一个原函数映射成一个导函数。那微分呢？ <span class="math display">\[
\begin{align}
y&amp;=x^2\\
\mathrm{d}y&amp;=2x\mathrm{d}x
\end{align}
\]</span> 是函数映射成函数吗？看着不像啊！这怎么又有<span class="math inline">\(x\)</span>又有<span class="math inline">\(\mathrm{d}x\)</span>，难道是二元函数？</p>
<p>你可以这么理解，但是我认为一个（在数学上是等价的）更好的理解是：对于每一个<span class="math inline">\(x\)</span>，都有一个对应的函数<span class="math inline">\(g(\mathrm{d}x)=2x\mathrm{d}x\)</span>. 这个函数是<span class="math inline">\(y\)</span>在<span class="math inline">\(x\)</span>附近的<strong>线性近似</strong>。微分就是把一个函数映射到这样一个实数到函数的映射（若嫌麻烦也可以理解成二元函数）上面。</p>
<p>到这里，有必要解释一下为啥书里面不先介绍微分了。这其实是个历史遗留问题。微分的符号<span class="math inline">\(\mathrm{d}\)</span>最早是莱布尼茨发明的（顺便一提，积分符号也是他发明的），他把<span class="math inline">\(\Delta x\)</span>和<span class="math inline">\(\Delta y\)</span>当成是有限的增量，对应的<span class="math inline">\(\mathrm{d}x\)</span>和<span class="math inline">\(\mathrm{d}y\)</span>就是无穷小增量。然而麻烦的是，莱布尼茨对于无穷小和微分的定义是很不精确的（莱布尼茨发明微积分的时候还没有极限的严格定义，具体可以参考<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/21199/is-frac-textrmdy-textrmdx-not-a-ratio">这里的回答</a>），所以我们现在学习的<strong>并不是他的理论</strong>。然而我们要学他的符号，因为这已经是“惯例”了。我们学习的是 <span class="math display">\[
\dfrac{\mathrm{d}}{\mathrm{d}x}y=\lim _{\Delta x\to 0}{\frac {\Delta y}{\Delta x}}
\]</span> 其中<span class="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>就是一个写得比较奇怪的记号。那么你可能会问：先讲微分，不就没这么多破事了吗？不好意思，不行。因为我们现在采用的是柯西给出的微积分定义（极限的严格定义也是柯西给出的）。他是用导数定义微分的： <span class="math display">\[
\mathrm{d}y=f&#39;(x)\mathrm{d}x.
\]</span> 这下死循环了。所以编书者没办法，就这么将就学吧。</p>
<p>有人会问：不是说牛顿和莱布尼茨同时发明了微积分吗？牛顿的符号为啥没流传下来呢？其实现在也在用，就是<span class="math inline">\(\dot {y}\)</span>，表示<span class="math inline">\(y\)</span>的一阶导数，二阶就是加两个点，三阶就是加三个点，以此类推。但是这样写并没有显式地指明自变量是什么，容易造成误解。</p>
<p>莱布尼茨符号流行的另外一个原因是它能辅助记忆用于微分和积分的公式。比如链式法则：假设函数<span class="math inline">\(g\)</span>在<span class="math inline">\(x\)</span>处可微，<span class="math inline">\(y = f(u)\)</span>在<span class="math inline">\(u = g(x)\)</span>处可微。那么复合函数<span class="math inline">\(y = f(g(x))\)</span>在<span class="math inline">\(x\)</span>处是可微的，其导数用莱布尼茨符号表示为： <span class="math display">\[
\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\cdot \dfrac{\mathrm{d}u}{\mathrm{d}x}
\]</span> 把<span class="math inline">\(\mathrm{d}u\)</span>消……等等！谁告诉你能这么消的？ <span class="math display">\[
\dfrac{\mathrm{d}y}{\mathrm{d}x}=\lim _{\Delta u\to 0}{\frac {\Delta y}{\Delta u}} \cdot \lim _{\Delta x\to 0}{\frac {\Delta u}{\Delta x}}
\]</span> 用极限形式写出来。显然，这两个极限的变量都不一样，不可以消去。</p>
<p>如果要证明链式法则，我们可以利用微分的概念。 <span class="math display">\[
\begin{align}
\Delta y&amp;=f&#39;(u)\Delta u+o(\Delta u)\\
&amp;=f&#39;(u)\left[g&#39;(x)\Delta x+o(\Delta x)\right]+o(\Delta u)\\
&amp;=f&#39;(u)g&#39;(x)\Delta x+f&#39;(u)\cdot o(\Delta x)+o(\Delta u)
\end{align}
\]</span> 所以 <span class="math display">\[
\mathrm{d}y=f&#39;(u)\mathrm{d}u=f&#39;(u)g&#39;(x)\mathrm{d}x
\]</span> 书中用导数定义微分，因此复合函数的微分法则就是由链式法则推出。但是我个人感觉这样的写法更自然好懂：既然我要的是线性近似，那么自变量<span class="math inline">\(u\)</span>当然也可以被它自己的线性近似替代。</p>
<p>有了链式法则，我们就有了<strong>一阶微分形式不变性</strong>：对于上面的自变量的微分<span class="math inline">\(\mathrm{d}u\)</span>，我们原先把它看作自变量的增量<span class="math inline">\(\Delta u\)</span>，但是现在我们发现如果<span class="math inline">\(u\)</span>又作为另外一个函数<span class="math inline">\(g\)</span>的因变量，<span class="math inline">\(\mathrm{d}u\)</span>可以直接被替换成它求微分的结果<span class="math inline">\(g&#39;(x)\mathrm{d}x\)</span>.</p>
<p>那既然对谁微分都是一样的形式，岂不是自变量就不重要了？所以<span class="math inline">\(\mathrm{d}\)</span>无论出现在哪里都是一个意思，无论<span class="math inline">\(y\)</span>对应的自变量是<span class="math inline">\(x\)</span>还是<span class="math inline">\(v\)</span>？</p>
<p>错。我们上面说的微分形式不变性是对于<strong>一阶微分</strong>而言的，对于二阶微分会是什么样的情况呢？</p>
<p>对于二阶导数，书中是这么写的 <span class="math display">\[
f&#39;&#39;(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}\left(\dfrac{\mathrm{d}y}{\mathrm{d}x}\right)=\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}
\]</span></p>
<p>看着也挺怪的，我们用微分写 <span class="math display">\[
\begin{align}
\mathrm{d}^2y&amp;=\mathrm{d}(\mathrm{d}y)\\
&amp;=\mathrm{d}(f&#39;(x)\mathrm{d}x)\\
&amp;=\mathrm{d}(f&#39;(x))\mathrm{d}x+f&#39;(x)\mathrm{d}(\mathrm{d}x)\\
&amp;=(f&#39;&#39;(x)\mathrm{d}x)\mathrm{d}x+f&#39;(x)\mathrm{d}^2x\\
&amp;=f&#39;&#39;(x)\mathrm{d}x^2+f&#39;(x)\mathrm{d}^2x
\end{align}
\]</span></p>
<p>好像多了一项<span class="math inline">\(f&#39;(x)\mathrm{d}^2x\)</span>？</p>
<p>这就是为什么微分形式不变性对于二阶微分不成立！二阶微分不但会受<span class="math inline">\(\mathrm{d}x^{2}\)</span>影响，也会受<span class="math inline">\(\mathrm{d^2}x\)</span>影响。</p>
<p>我们若是想得到二阶导数的形式，就必须把<span class="math inline">\(x\)</span><strong>看成自变量而不是一个可微的函数</strong>，我们实际上求的是对<span class="math inline">\(\mathrm{d}x\)</span>的偏微分</p>
<p><span class="math display">\[
\left(\partial ^ 2 y\right) _ {\mathrm{d}x}=f&#39;&#39;(x)\mathrm{d}x^2
\]</span></p>
<p>所以，二阶微分不具有形式不变性。</p>
<p>现在来说积分。这里直接跳过书上的“记作”论调，重新定义：积分就是微分的<strong>逆运算</strong>。回想起我们对微分的理解：微分就是把一个函数映射到一个“实数到函数的映射”（若嫌麻烦也可以理解成二元函数）上面。那么积分就是微分的<strong>逆映射</strong>。给一个实数到函数的映射（二元函数），就能对应回一个函数上。嗯？等等，微分这个映射并不是单射，不同的函数也可能有相同的微分。那怎么办呢？我们给它打个补丁：由于有相同微分的原函数互相都只相差某个常数，我们就把积分定义成一个实数到函数的映射对应一个函数集合。这个函数集合中的函数互相都只相差某个常数，我们就用<span class="math inline">\(F(x)+C\)</span>来表示这个函数集合。</p>
<p>从定义立即可以得到，如果在区间<span class="math inline">\(I\)</span>上可导函数<span class="math inline">\(F(x)\)</span>的导函数为<span class="math inline">\(f(x)\)</span>，对任一<span class="math inline">\(x\in I\)</span>，都有 <span class="math display">\[
\int \mathrm{d}F(x)=\int f(x)\mathrm{d}x=F(x)+C.
\]</span> 回到上面的复合函数，如果<span class="math inline">\(f(u)\)</span>具有原函数<span class="math inline">\(F(u)\)</span>，由微分形式不变性，有 <span class="math display">\[
\int f(g(x))g&#39;(x)\mathrm{d}x=\int f&#39;(u)\mathrm{d}u=F(u)+C
\]</span> 这就是换元积分法中的<strong>第一类换元法</strong>。其实，这就是对被积表达式部分积分。</p>
<p>我们也可以反向操作：</p>
<p>令<span class="math inline">\(t=\phi ^{-1}(x)\)</span>，则<span class="math inline">\(x=\phi (t)\)</span>，有 <span class="math display">\[
\int f(x)\mathrm{d}x=\int f(\phi (t))\mathrm{d}\phi (t)=\int f(\phi (t))\phi &#39;(t)\mathrm{d}t
\]</span> 这就是换元积分法中的<strong>第二类换元法</strong>。</p>
<p>微分法则能启发我们计算积分，比如：对于在区间<span class="math inline">\(I\)</span>上的可微函数<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g(x)\)</span>有 <span class="math display">\[
\begin{aligned}
\mathrm{d}\left[f(x)g(x)\right]&amp;=f(x)\cdot \mathrm{d}g(x)+\mathrm{d}f(x)\cdot g(x)\\
&amp;=f(x)g&#39;(x)\mathrm{d}x+f&#39;(x)g(x)\mathrm{d}x
\end{aligned}
\]</span> 两边积分得 <span class="math display">\[
\int \mathrm{d}\left[f(x)g(x)\right]=\int f(x)g&#39;(x)\mathrm{d}x+\int f&#39;(x)g(x)\mathrm{d}x
\]</span> 即 <span class="math display">\[
\int f(x)g&#39;(x)\mathrm{d}x=f(x)g(x)-\int f&#39;(x)g(x)\mathrm{d}x
\]</span> 这就是<strong>分部积分法</strong>。也可以写成简洁形式 <span class="math display">\[
\int u\mathrm{d}v=uv-\int v\mathrm{d}u
\]</span> 如果你想要理解这些积分法则，这里有一个线索：第一、第二类换元法对应的是复合函数，分部积分法对应的是两个函数的乘积运算。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qW411N7FU?p=4">这个视频</a> 也许也能帮助你更直观地理解。</p>
<p>学积分的时候应该注意思考积分法则的逆运算（逆操作）是什么。如果能明白简单的积分形式是怎么变复杂的，看到复杂的积分也就不难化简了。上面这三种积分法则的逆运算是什么呢？</p>
<p>很容易发现第一类、第二类换元法是互为逆运算的。而分部积分法的逆运算是它自己 <span class="math display">\[
\int u\mathrm{d}v=uv-\int v\mathrm{d}u=uv-\left(uv- \int u\mathrm{d}v \right)=\int u\mathrm{d}v
\]</span></p>
<p><strong>References:</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/li-hua/p/6617366.html">迷之记号 dx 到底是什么鬼</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30296338/answer/120574352">什么是微分形式不变性？一阶微分形式不变性与链式法则是等价的吗（两者可互推？）？两者有什么区别？ - 马同学的回答</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26490937">微分符号 dx、dy 表示什么含义？</a></li>
<li><a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/21199/is-frac-textrmdy-textrmdx-not-a-ratio">Is d/dx not a ratio?</a></li>
<li><a target="_blank" rel="noopener" href="https://math.stackexchange.com/a/3561534/858590">The second differential versus the differential of a differential form</a></li>
</ol>
<h2 id="积分中的魔法">积分中的魔法</h2>
<p>积分有什么用呢？</p>
<p>要解释积分的用途，我们要提一个很经典的问题：求曲边梯形的面积。也就是说，我们想知道由两条垂直于<span class="math inline">\(x\)</span>轴的直线，一条函数曲线<span class="math inline">\(y = f(x)\)</span>和<span class="math inline">\(x\)</span>轴围成区域的面积。</p>
<p>首先我们得岔开话题，先讲积分的一个有趣的性质。</p>
<p>我们学过拉格朗日中值定理（均值定理）：函数<span class="math inline">\(f(x)\)</span>若在<span class="math inline">\([a,b]\)</span>内连续，<span class="math inline">\((a,b)\)</span>内可导，存在<span class="math inline">\(\xi \in (a,b)\)</span>使 <span class="math display">\[
f(b)-f(a)=f&#39;( \xi )(b-a)
\]</span> 我们可以尝试把这个定理应用到原函数<span class="math inline">\(F(x)\)</span>上 <span class="math display">\[
F(b)-F(a)=F&#39;( \xi )(b-a)=f( \xi )(b-a)
\]</span> 等式右边是什么意思呢？它看着像是长为<span class="math inline">\(f(\xi )\)</span>宽为<span class="math inline">\(b-a\)</span>的长方形的面积。</p>
<p>微积分的核心思想之一，是把宏观的、难以解决的问题转化为很多局部的、近似的问题。</p>
<p>我们可以这么写 <span class="math display">\[
F(x+\Delta x)-F(x)=f( \xi )\Delta x
\]</span> 等式右边的意思是说，在一个很小的宽为<span class="math inline">\(\Delta x\)</span>的区间内，其中一点<span class="math inline">\(\xi\)</span>的函数值为长，<span class="math inline">\(\Delta x\)</span>为宽围成的面积。</p>
<p>微积分的核心思想之二是极限。在不断趋近的过程中证明要多近有多近。</p>
<p>在这里我们首先要做的是趋近。证明当<span class="math inline">\(\Delta x \to 0\)</span>时<span class="math inline">\(f( \xi )\Delta x\)</span>可以任意的接近<span class="math inline">\(\Delta x\)</span>为宽的那个区间内的曲边梯形面积。也就是说 <span class="math display">\[
\Delta A=\lim_{\Delta x \to 0}{f( \xi )\Delta x}
\]</span> 好吧，这个证明有点冗长，有时间再补。</p>
<p>下一步，就是积。把区间<span class="math inline">\([a,b]\)</span>分成<span class="math inline">\(n\)</span>份，每一份的宽度为<span class="math inline">\(\Delta x = \frac{b-a}{n}\)</span>，左右端点为<span class="math inline">\([x_{i-1},x_i]\)</span>，有 <span class="math display">\[
F(x_n)-F(x_{n-1})+F(x_{n-1})-F(x_{n-2})+\cdots+F(x_1)-F(x_0)=\sum ^{n}_{i=1}\left[f\left( \xi _{i}\right) \Delta x \right]
\]</span> 这时候，奇迹发生了： <span class="math display">\[
F(x_n)-F(x_0)=F(b)-F(a)=\sum ^{n}_{i=1}\left[ f\left( \xi _{i}\right) \Delta x \right]
\]</span> 左边中间的项全部被消掉，这时候我们发现，等式左边跟<span class="math inline">\(n\)</span><strong>无关</strong>了。也就是说，我们可以自信地写下 <span class="math display">\[
F(b)-F(a)=\lim_{n\to \infty}{\sum ^{n}_{i=1}{\frac{f\left( \xi _{i}\right) (b-a)}{n}}}=\lim_{n\to \infty}{\sum ^{n}_{i=1}{\Delta A_i}}=A
\]</span> 原本看上去不可能的问题，就这么被轻易解决了。</p>
<p>由于很多问题都可以用类似求曲边梯形的方法解答，我们专门给<span class="math inline">\(F(b)-F(a)\)</span>分配了符号，并称之为<span class="math inline">\(f(x)\)</span>在区间<span class="math inline">\([a,b]\)</span>上的<strong>定积分</strong>： <span class="math display">\[
\int_{a}^{b} f(x)\mathrm{d}x=F(b)-F(a)
\]</span> 上面的性质也成了积分中值定理 <span class="math display">\[
\int_{a}^{b} f(x)\mathrm{d}x=f( \xi )(b-a)
\]</span></p>
<h2 id="从等价无穷小到泰勒公式">从等价无穷小到泰勒公式</h2>
<h3 id="启程">启程</h3>
<p>在第 1.7 节 无穷小的比较中就介绍了等价无穷小：</p>
<blockquote>
<p>如果 <span class="math inline">\(\lim \dfrac{\beta}{\alpha}=1\)</span>，那么就说 <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\alpha\)</span> 是等价无穷小，记作 <span class="math inline">\(\alpha \sim \beta\)</span>.</p>
</blockquote>
<p>比如 <span class="math display">\[
\sin x \sim x \ (x\to 0)
\]</span> 等价无穷小有什么特别的，以至于要专门给他分配个符号呢？</p>
<p>由极限运算法则，如果 <span class="math inline">\(\lim f(x)=A\)</span>，<span class="math inline">\(\lim g(x)=B\)</span>，那么 <span class="math display">\[
\lim[f(x)\cdot g(x)]=\lim f(x)\cdot \lim g(x)=A\cdot B
\]</span> 所以 <span class="math display">\[
\lim_{x\to 0} f(x) = \lim_{x\to 0} f(x) \cdot \lim_{x\to 0}\dfrac{\sin x}{x} = \lim_{x\to 0} \left[ f(x) \cdot \dfrac{\sin x}{x} \right]
\]</span> 来看个实际用例： <span class="math display">\[
\lim _{x\rightarrow 0}\dfrac{\sin x}{x^{3}+3x}=\lim _{x\rightarrow 0}\left( \dfrac{\sin x}{x^{3}+3x}\cdot \dfrac{x}{\sin x}\right) = \lim _{x\rightarrow 0}\dfrac{x}{x(x^{2}+3)} = \dfrac{1}{3}
\]</span> 常用的等价无穷小还有 <span class="math display">\[
\begin{aligned}
e^x-1&amp;\sim x\ (x\to 0)\\
\ln (1+x)&amp;\sim x\ (x\to 0)
\end{aligned}
\]</span></p>
<h3 id="岔路">岔路</h3>
<p>过了一段时间，你学到了拉格朗日中值公式。如果（省略）则 <span class="math display">\[
f(b)-f(a)=f&#39;( \xi )(b-a)
\]</span> 回到上面那个实际用例。我们可以说，由 <span class="math inline">\(\sin x\)</span> 在 <span class="math inline">\(x=0\)</span> 的某一去心邻域内可导，所以存在 <span class="math inline">\(\xi \in \mathring{U}(0,x)\)</span> 使得 <span class="math display">\[
\sin x-\sin 0=\cos \xi(x-0)
\]</span> 当 <span class="math inline">\(x\to 0\)</span> 时有 <span class="math display">\[
\lim_{x\to 0}\dfrac{\sin x}{x}=\lim_{x\to 0}\dfrac{\sin x-\sin 0}{x-0}=\lim_{x\to 0}\cos \xi=1
\]</span> 看起来有点意思？还有更有意思的。</p>
<p>如果 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\(a\)</span> 的某去心邻域内可导，当 <span class="math inline">\(x\to a\)</span> 时函数 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 都趋于零，对于下面这个极限 <span class="math display">\[
\lim_{x\to a}\frac{f(x)}{g(x)}
\]</span> 我们可以把上面的方法同时应用到分子分母上。我们为了连续性假定 <span class="math inline">\(f(a)=g(a)=0\)</span> 则此时两函数在 <span class="math inline">\(a\)</span> 的某邻域内连续。</p>
<p>存在 <span class="math inline">\(\xi_1 \in \mathring{U}(a,x), \xi_2 \in \mathring{U}(a,x)\)</span>​ 使得 <span class="math display">\[
\begin{aligned}
f(x)-f(a)&amp;=f&#39;(\xi_1)(x-a)\\
g(x)-g(a)&amp;=g&#39;(\xi_2)(x-a)
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(g&#39;(x)\neq 0\)</span>，有 <span class="math display">\[
\lim_{x\to a}\dfrac{f(x)}{g(x)}=\lim_{x\to a}\dfrac{f(x)-f(a)}{g(x)-g(a)}=\lim_{x\to a}\frac{f&#39;(\xi_1)(x-a)}{g&#39;(\xi_2)(x-a)}=\lim_{x\to a}\frac{f&#39;(x)}{g&#39;(x)}
\]</span> 洛必达法则！实际上证明洛必达法则并不依赖柯西中值定理。</p>
<p>上面的推导启示我们，洛必达法则和等价无穷小有某种意义上的联系。若函数 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\(x=x_0\)</span> 的某邻域内 <span class="math inline">\(n\)</span> 阶可导，且当 <span class="math inline">\(x\to x_0\)</span> 时 <span class="math inline">\(f(x)\sim g(x)\)</span> 则 <span class="math display">\[
\lim_{x\to x_0}\dfrac{f(x)}{g(x)}=\lim_{x\to x_0}\frac{f^{(n)}(x)}{g^{(n)}(x)}=1
\]</span> 另外，在这个过程中你可能会发现 <span class="math display">\[
\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(\xi_1)(b-a)}{g&#39;(\xi_2)(b-a)}=\frac{f&#39;(\xi_1)}{g&#39;(\xi_2)}
\]</span> 柯西中值定理？其实并不是，柯西中值定理还需要 <span class="math inline">\(\xi_1=\xi_2\)</span>​，构造 <span class="math display">\[
h(x) = [f(x) - f(a)][g(b) - g(a)] - [g(x) - g(a)][f(b) - f(a)].
\]</span> 显然 <span class="math inline">\(h(a)=h(b)=0\)</span>​，由罗尔中值定理得 <span class="math display">\[
0 = h&#39;(\xi) = f&#39;(\xi)(g(b) - g(a)) - g&#39;(\xi)(f(b) - f(a))
\]</span></p>
<p>为什么同济高数书上要写成这么别扭的样子呢？ <span class="math display">\[
h(x)=f(x)-\frac{f(b)-f(a)}{g(b)-g(a)}g(x)
\]</span> 我猜大概是为了强调 <span class="math inline">\(g(b)-g(a)\neq 0\)</span> 吧（由 <span class="math inline">\(g&#39;(x)\neq 0\)</span> 推出）</p>
<p>再来看一个洛必达法则的证明：</p>
<p>若 <span class="math inline">\(f, g : (a, b) \to R\)</span> 在 <span class="math inline">\(x_0 \in (a,b)\)</span> 上可导，且 <span class="math inline">\(f(x_0)=g(x_0)=0\)</span>，<span class="math inline">\(g&#39;(x_0)\neq 0\)</span>. 则 <span class="math display">\[
\frac{f&#39;(x_0)}{g&#39;(x_0)}=\frac{\lim_{x\to x_0}{\frac{f(x)-f(x_0)}{x-x_0}}}{\lim_{x\to x_0}{\frac{g(x)-g(x_0)}{x-x_0}}}=\lim_{x\to x_0}{\frac{f(x)-f(x_0)}{g(x)-g(x_0)}}=\lim_{x\to x_0}{\frac{f(x)}{g(x)}}
\]</span> 这就证完了？能用一行证明，为什么上面要绕一大圈？</p>
<p>请注意洛必达法则的条件</p>
<blockquote>
<ol type="1">
<li>当 <span class="math inline">\(x\to x_0\)</span> 时，函数 <span class="math inline">\(f(x)\)</span> 及 <span class="math inline">\(g(x)\)</span> 都趋于零.</li>
<li>在点 <span class="math inline">\(x_0\)</span> 的<strong>某去心邻域内</strong>，<span class="math inline">\(f&#39;(x)\)</span> 及 <span class="math inline">\(g&#39;(x)\)</span> 都存在且 <span class="math inline">\(g&#39;(x)\neq 0\)</span>.</li>
<li><span class="math inline">\(\lim_{x\to x_0}{\frac{f&#39;(x)}{g&#39;(x)}}\)</span> 存在（或为无穷大）.</li>
</ol>
</blockquote>
<p>其中第 1、2 点都不一样，但是证明时假定了 <span class="math inline">\(f(x_0)=g(x_0)=0\)</span> 所以实际上第 1 点没有区别。最关键的是第 2 点：<span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 只需要在 <span class="math inline">\(x_0\)</span> 的某去心邻域可导，不需要在 <span class="math inline">\(x_0\)</span> 可导。与之相对应，公式中也是取两函数导数的比值的极限。</p>
<h3 id="迷途">迷途</h3>
<p>我们来看一道 经 典 例 题： <span class="math display">\[
\lim_{x\to0}\left(\frac{e^x +xe^x}{e^x-1}-\frac{1}{x}\right)
\]</span> 你可能会这么写： <span class="math display">\[
\begin{aligned}
\lim_{x\to 0}\left(\frac{e^x +xe^x}{e^x-1}-\frac{1}{x}\right)&amp;=\lim_{x\to 0}\frac{e^x +xe^x}{e^x-1} - \lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\frac{e^x +xe^x}{e^x-1}\times \lim_{x\to 0}\frac{e^x-1}{x}-\lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\left(\frac{e^x +xe^x}{e^x-1} \times \frac{e^x-1}{x}\right)-\lim_{x\to 0}\frac{1}{x} \\
&amp;=\lim_{x\to 0}\left(\frac{e^x +xe^x}{x}-\frac{1}{x}\right) \\
&amp;=\lim_{x\to 0}\frac{e^x +xe^x-1}{x} \\
&amp;=\lim_{x\to 0}\left(2e^x-xe^x\right) \\
&amp;=2
\end{aligned}
\]</span></p>
<p>然而！答案是 <span class="math inline">\(\frac{2}{3}\)</span>.</p>
<p>错在哪呢？其实第一步就错了，拆出来成了 <span class="math inline">\(\infty -\infty\)</span>，而极限运算法则<strong>只在两极限存在时才成立</strong>，不能拆。如果你不是这么做的但是得到了错误的结果，请自行根据 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62029838">这篇文章</a> 对号入座。</p>
<p>辅导书和老师可能会告诉你，等价无穷小的用法仅限于极限值整体乘以 1 再代换！这种说法确实没错，但是事情是不是就这么简单地结束了呢？为什么有的情况下替换不会出现问题呢？</p>
<p>请看同济高数第 1-7 节定理 1: <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\alpha\)</span> 是等价无穷小的充分必要条件为 <span class="math display">\[
\beta=\alpha + o(\alpha)
\]</span> 可以看出，两个等价无穷小之间差了一个高阶无穷小。那么什么时候不能用等价无穷小呢？</p>
<p>就是除了无穷小以外的量全部都被消去的情况，这时候高阶无穷小才会左右极限的结果，而它会受到等价无穷小替换的影响而不准确。</p>
<p>也就是说</p>
<blockquote>
<p>已知 <span class="math inline">\(\lim_{x\to x_0}{\frac{\alpha_1}{\alpha_2}}\)</span> 存在， <span class="math inline">\(\alpha_1,\alpha_{2},\beta_{1},\beta_{2}\)</span> 都是 <span class="math inline">\(x\rightarrow x_0\)</span> 的无穷小量，且 <span class="math inline">\(\alpha_1\sim\beta_1\)</span>，<span class="math inline">\(\alpha_{2}\sim\beta_{2}\)</span>.</p>
<p>若 <span class="math inline">\(\lim_{x\rightarrow x_0}{\frac{\alpha_1}{\alpha_2}} \neq 1\)</span> （两者的泰勒展开的第一项不相同），则 <span class="math inline">\(\alpha_1-\alpha_2\sim \beta_1-\beta_2\)</span>;</p>
<p>若 <span class="math inline">\(\lim_{x\rightarrow x_0}{\frac{\alpha_1}{\alpha_2}} \neq -1\)</span>（两者的泰勒展开的第一项不互为相反数），则 <span class="math inline">\(\alpha_1+\alpha_2\sim\beta_1+\beta_2\)</span>.</p>
</blockquote>
<h3 id="终点">终点</h3>
<p>上面看似已经把等价无穷小的用法说清楚了，但是还有很多隐藏的问题。比如说，极限运算法则必须要两个极限存在才成立，那么如果我要求的极限本来就不存在呢？难道我每次用之前还要证明这个极限存在？</p>
<p>所以我们不如用回等价无穷小的充要条件 <span class="math display">\[
\alpha \sim \beta \Leftrightarrow \beta=\alpha + o(\alpha)
\]</span> 等价替换永远是最直接、最少出错的。</p>
<p>而实际上我们用等价无穷小的时候几乎从来都是换成多项式函数，因为它好化简、好求极限。</p>
<p>又过了一段时间，你学到了泰勒公式，它是拉格朗日中值公式的推广（令 <span class="math inline">\(n=2m\)</span>） <span class="math display">\[
\begin{align}
\sin \left(x\right)&amp;= x-{\frac {x^{3}}{3!}}+{\frac {x^{5}}{5!}}-{\frac {x^{7}}{7!}}+\cdots +(-1)^{m-1}\dfrac{x^{2m-1}}{(2m-1)!}+o(x^{2m})\\
e^{x}&amp;=1+x+{\frac {x^{2}}{2!}}+{\frac {x^{3}}{3!}}+\cdots +\frac{x^{n-1}}{(n-1)!} +o(x^n)\\
\ln(1+x)&amp;=x-{\frac {x^{2}}{2}}+{\frac {x^{3}}{3}}-\cdots+(-1)^{n-1}\dfrac{1}{n}x^n+o(x^n)
\end{align}
\]</span></p>
<p>接下来不用多说了吧。<strong>用泰勒公式，别用等价无穷小。</strong></p>
<p>后记：这篇文章写的很混乱，中途删了又写，写了又删。最后终于在高数期末考前仓促结尾，行文思路混乱，更别说严谨性。现在回头反思，总感觉自己太过于相信自己的所谓直觉，推导一番后又发现和目标不搭边。总结：想的太多，读的太少，算的更少。</p>
<p><strong>References:</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://www.math.pitt.edu/~sparling/23012/23012lhopital1/node1.html">Cauchy's Mean Value Theorem and L'Hopital's rule</a></li>
<li><a target="_blank" rel="noopener" href="https://home.iitk.ac.in/~psraj/mth101/lecture_notes/lecture7.pdf">(PDF)Lecture 7 : Cauchy Mean Value Theorem, L'Hospital Rule</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62029838">高数常见坑点：等价无穷小</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99373470">“等价无穷小量的替换”的详析 - 李亦督的文章 - 知乎</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard Zheng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
